<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js - misc - octree collisions</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="main.css" />
    <style>
      #legend {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background-color: rgba(40, 40, 40, 0.8);
        color: white;
        font-size: 14px;
        padding: 10px;
        border-radius: 8px;
        z-index: 100;
        font-family: sans-serif;
      }

      #zoom-controls {
        position: absolute;
        bottom: 10px;
        right: 10px;
        display: flex;
        flex-direction: column;
        gap: 6px;
        z-index: 101;
      }

      #zoom-controls button {
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        border: none;
        padding: 8px 12px;
        font-size: 18px;
        border-radius: 6px;
        cursor: pointer;
      }

      #zoom-controls button:hover {
        background-color: rgba(255, 255, 255, 0.2);
      }

      .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 6px;
      }

      .legend-color {
        width: 16px;
        height: 16px;
        margin-right: 8px;
        border: 1px solid #ccc;
        box-sizing: border-box;
      }

      .rack {
        background-color: rgba(88, 101, 242, 0.2);
      }
      .space {
        background-color: rgba(0, 255, 0, 0.2);
      }
      .buffer {
        background-color: rgba(212, 140, 140, 0.7);
      }
      .corridor {
        background-color: rgba(51, 153, 255, 0.2);
        border: 1px solid #3399ff;
      }

      #view-controls {
        position: absolute;
        top: 70px;
        right: 10px;
        z-index: 102;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 12px 14px;
        border-radius: 8px;
        font-family: sans-serif;
        font-size: 14px;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      #view-controls .label {
        font-weight: bold;
        margin-bottom: 6px;
      }

      #view-controls label {
        display: flex;
        align-items: center;
        gap: 6px;
        cursor: pointer;
      }

      #level-controls {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px 12px;
        border-radius: 8px;
        font-family: sans-serif;
        font-size: 14px;
        z-index: 103;
      }
      #level-controls select {
        margin-left: 5px;
        padding: 3px;
      }
    </style>
  </head>
  <body>
    <div id="info">
      RATO para olhar em redor<br />
      WASD para mover e ESPAÇO para saltar<br />
      T para trocar de camera
    </div>
    <div id="container"></div>
    <div id="zoom-controls">
      <button id="zoom-in">+</button>
      <button id="zoom-out">−</button>
      <button id="reset-topcam">↺</button>
    </div>

    <div id="legend">
      <div class="legend-item">
        <div class="legend-color rack"></div>
        Racks (caixas azuis translúcidas)
      </div>
      <div class="legend-item">
        <div class="legend-color space"></div>
        Picking(verde)
      </div>
      <div class="legend-item">
        <div class="legend-color buffer"></div>
        Buffers (rosa)
      </div>
      <div class="legend-item">
        <div class="legend-color corridor"></div>
        Corridors (planos azuis semi-translúcidos)
      </div>

      <div class="legend-item">
        <div class="legend-color dock" style="background-color: #ffa500"></div>
        Cais (laranja)
      </div>
      <div class="legend-item">
        <div class="legend-color stack" style="background-color: #9966ff"></div>
        Pilhas (roxo)
      </div>
      <div class="legend-item">
        <div class="legend-color stack" style="background-color: #00ccff"></div>
        Drive In (roxo)
      </div>
    </div>

    <div
      id="tooltip"
      style="
        position: absolute;
        color: white;
        background: rgba(0, 0, 0, 0.8);
        padding: 6px 10px;
        border-radius: 5px;
        font-size: 14px;
        pointer-events: none;
        z-index: 999;
        display: none;
        font-family: sans-serif;
      "
    ></div>

    <div id="container"></div>

    <div id="view-controls">
      <span class="label">Visibilidade:</span>
      <label><input type="checkbox" value="racks" checked /> Racks</label>
      <label
        ><input type="checkbox" value="corridors" checked /> Corridors</label
      >
      <label><input type="checkbox" value="buffers" checked /> Buffers</label>
      <label><input type="checkbox" value="spaces" checked /> Picking</label>
      <label><input type="checkbox" value="docks" checked /> Cais</label>
      <label><input type="checkbox" value="stacks" checked /> Pilhas</label>
      <label><input type="checkbox" value="driveins" checked /> DriveIns</label>
    </div>

    <div id="level-controls">
      <label for="buffer-level">Nível máximo de buffers por rack:</label>
      <select id="buffer-level">
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10" selected>10</option>
      </select>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "./three/build/three.module.js",
          "three/addons/": "./three/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import Stats from "three/addons/libs/stats.module.js";
      import { Octree } from "three/addons/math/Octree.js";
      import { OctreeHelper } from "three/addons/helpers/OctreeHelper.js";
      import { Capsule } from "three/addons/math/Capsule.js";
      import { GUI } from "three/addons/libs/lil-gui.module.min.js";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      //import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js'; -> GM nao quero utilizar GLTF Loaders estragam-me os FPS
      import {
        CSS2DRenderer,
        CSS2DObject,
      } from "./three/examples/jsm/renderers/CSS2DRenderer.js";

      const clock = new THREE.Clock();
      let wallBoundingBoxCoords;
      let racks;
      let spaces;
      let boundingBoxCenter = new THREE.Vector3();
      let rackMeshes = []; // Add this at the top of your script
      let dockMeshes = [];
      let stackMeshes = [];
      let corridorMeshes = [];
      let driveInMeshes = [];

      //const gltfLoader = new GLTFLoader();  -> GM nao quero utilizar GLTF Loaders estragam-me os FPS

      const scene = new THREE.Scene();
      //Mudança das core GM
      scene.background = new THREE.Color(0x252c3f);

      let instancedMesh;

      const camera = new THREE.PerspectiveCamera(
        70,
        window.innerWidth / window.innerHeight,
        0.1,
        10000
      );
      camera.position.set(50, 1, 50); // ou boundingBoxCenter quando disponível
      camera.rotation.set(0, 0, 0); // olhe para frente
      camera.up.set(0, 1, 0);

      camera.rotation.order = "YXZ";

      const aspect = window.innerWidth / window.innerHeight;
      const topCamera = new THREE.PerspectiveCamera(
        20,
        window.innerWidth / window.innerHeight,
        1,
        10000
      );

      topCamera.position.set(50, 100, 50); // Starting high above the warehouse
      const initialTopCamPosition = new THREE.Vector3(50, 100, 50);
      const initialTopCamTarget = new THREE.Vector3(50, 0, 50);
      topCamera.position.copy(initialTopCamPosition);
      topCamera.lookAt(initialTopCamTarget);

      // Zoom control logic
      const zoomInBtn = document.getElementById("zoom-in");
      const zoomOutBtn = document.getElementById("zoom-out");

      let activeCamera = camera;

      //Resetar a top camera ao default
      const resetTopCamBtn = document.getElementById("reset-topcam");

      const viewCheckboxes = document.querySelectorAll(
        '#view-controls input[type="checkbox"]'
      );

      const bufferLevelSelect = document.getElementById("buffer-level");
      let currentMaxBufferLevel = parseInt(bufferLevelSelect.value);

      bufferLevelSelect.addEventListener("change", () => {
        currentMaxBufferLevel = parseInt(bufferLevelSelect.value);
        updateBufferLevels(currentMaxBufferLevel);
      });
      function updateBufferLevels(maxLevel) {
        if (!bufferGroup || bufferGroup.children.length === 0) return;

        const instancedMesh = bufferGroup.children.find(
          (child) => child.isInstancedMesh
        );
        if (!instancedMesh) return;

        const dummy = new THREE.Object3D();
        const count = instancedMesh.count;

        const tolerance = 0.1; // Para agrupar por (x,z)
        const yTolerance = 0.05; // Para agrupar níveis em Y

        // Agrupar buffers por rack (x,z)
        const rackBuckets = [];

        for (let i = 0; i < count; i++) {
          instancedMesh.getMatrixAt(i, dummy.matrix);
          dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);

          const pos = dummy.position;
          let bucket = rackBuckets.find(
            (b) =>
              Math.abs(b.x - pos.x) < tolerance &&
              Math.abs(b.z - pos.z) < tolerance
          );

          if (!bucket) {
            bucket = { x: pos.x, z: pos.z, buffers: [] };
            rackBuckets.push(bucket);
          }

          bucket.buffers.push({ index: i, y: pos.y });
        }

        // Lógica por rack
        rackBuckets.forEach((bucket) => {
          const buffers = bucket.buffers;

          // Agrupar níveis únicos (mesmo que variação de Y pequena)
          const levels = [];

          buffers.forEach((buf) => {
            let found = levels.find(
              (levelY) => Math.abs(levelY - buf.y) < yTolerance
            );
            if (!found) {
              levels.push(buf.y);
            }
          });

          // Ordenar os níveis de baixo para cima
          levels.sort((a, b) => a - b);

          // Mostrar buffers se estão em nível permitido
          buffers.forEach((buf) => {
            instancedMesh.getMatrixAt(buf.index, dummy.matrix);
            dummy.matrix.decompose(
              dummy.position,
              dummy.quaternion,
              dummy.scale
            );

            // Descobrir qual nível este buffer pertence
            const logicalLevel = levels.findIndex(
              (y) => Math.abs(y - buf.y) < yTolerance
            );

            const show = logicalLevel >= 0 && logicalLevel < maxLevel;
            dummy.scale.setScalar(show ? 1 : 0.0001);
            dummy.updateMatrix();
            instancedMesh.setMatrixAt(buf.index, dummy.matrix);
          });
        });

        instancedMesh.instanceMatrix.needsUpdate = true;
      }

      viewCheckboxes.forEach((checkbox) => {
        checkbox.addEventListener("change", () => {
          const selected = Array.from(viewCheckboxes)
            .filter((cb) => cb.checked)
            .map((cb) => cb.value);

          rackGroup.visible = selected.includes("racks");
          corridorGroup.visible = selected.includes("corridors");
          bufferGroup.visible = selected.includes("buffers");
          spaceGroup.visible = selected.includes("spaces");
          dockGroup.visible = selected.includes("docks");
          stackGroup.visible = selected.includes("stacks");
          driveInGroup.visible = selected.includes("driveins");
        });
      });

      resetTopCamBtn.addEventListener("click", () => {
        if (activeCamera === topCamera) {
          topCamera.position.copy(initialTopCamPosition);
          orbitControls.target.copy(initialTopCamTarget);
          topCamera.lookAt(initialTopCamTarget);
          employeeModel.position.copy(initialTopCamPosition);
        }
      });

      // Aumentar a illuminação Global ALTERAÇÃO GM

      zoomInBtn.addEventListener("click", () => {
        if (activeCamera === topCamera) {
          topCamera.fov = Math.max(10, topCamera.fov - 5); // Min FOV = more zoom
          topCamera.updateProjectionMatrix();
        }
      });

      zoomOutBtn.addEventListener("click", () => {
        if (activeCamera === topCamera) {
          topCamera.fov = Math.min(100, topCamera.fov + 5); // Max FOV = less zoom
          topCamera.updateProjectionMatrix();
        }
      });

      //topCamera.position.set(50, 100, 50);
      //topCamera.lookAt(50, 0, 50);

      // Luz ambiente suave
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); // luz geral
      scene.add(ambientLight);

      // Luz direcional clara
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
      directionalLight.position.set(50, 50, 50);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      const container = document.getElementById("container");

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setAnimationLoop(animate);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.VSMShadowMap;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      container.appendChild(renderer.domElement);

      const stats = new Stats();
      stats.domElement.style.position = "absolute";
      stats.domElement.style.top = "0px";
      container.appendChild(stats.domElement);

      const GRAVITY = 30;
      const STEPS_PER_FRAME = 5;

      const worldOctree = new Octree();

      const playerCollider = new Capsule(
        new THREE.Vector3(50, 0.35, 50),
        new THREE.Vector3(50, 1, 50),
        0.35
      );

      const playerVelocity = new THREE.Vector3();
      const playerDirection = new THREE.Vector3();

      let playerOnFloor = false;
      let mouseTime = 0;

      const keyStates = {};

      const vector1 = new THREE.Vector3();
      const vector2 = new THREE.Vector3();
      const vector3 = new THREE.Vector3();

      let employeeModel;

      let rackGroup = new THREE.Group();
      let corridorGroup = new THREE.Group();
      let bufferGroup = new THREE.Group();
      let spaceGroup = new THREE.Group();
      let dockGroup = new THREE.Group();
      let stackGroup = new THREE.Group();
      let driveInGroup = new THREE.Group();

      scene.add(
        rackGroup,
        corridorGroup,
        bufferGroup,
        spaceGroup,
        dockGroup,
        stackGroup,
        driveInGroup
      );

      const tooltip = document.getElementById("tooltip");

      document.addEventListener("keydown", (event) => {
        keyStates[event.code] = true;

        if (event.code === "KeyT") {
          toggleCamera();
        }
      });

      document.addEventListener("keyup", (event) => {
        keyStates[event.code] = false;
      });

      container.addEventListener("mousedown", () => {
        if (
          activeCamera === camera &&
          document.pointerLockElement !== document.body
        ) {
          try {
            document.body.requestPointerLock();
            mouseTime = performance.now();
          } catch (e) {
            console.warn("Pointer lock request failed:", e);
          }
        }
      });

      document.body.addEventListener("mousemove", (event) => {
        if (
          document.pointerLockElement === document.body &&
          activeCamera === camera
        ) {
          mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
          if (document.pointerLockElement === document.body) {
            const sensitivity = 0.002;
            camera.rotation.y -= event.movementX * sensitivity;
            camera.rotation.x -= event.movementY * sensitivity;

            // Limita o olhar vertical (evita loop)
            const maxPitch = Math.PI / 2 - 0.1; // ligeiramente menos que 90°
            const minPitch = -Math.PI / 2 + 0.1; // ligeiramente mais que -90°
            camera.rotation.x = Math.max(
              minPitch,
              Math.min(maxPitch, camera.rotation.x)
            );
          }
        }
      });

      window.addEventListener("resize", onWindowResize);

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        topCamera.aspect = window.innerWidth / window.innerHeight;
        topCamera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Calculate the bounding box of all the racks and the center
      function calculateWallBoundingBox(racks) {
        const min = new THREE.Vector3(Infinity, Infinity, Infinity);
        const max = new THREE.Vector3(-Infinity, -Infinity, -Infinity);

        racks.forEach((rack) => {
          const position = new THREE.Vector3(
            rack.Spazio_coord_draw_a / 100,
            rack.Spazio_coord_draw_b / 100,
            rack.Spazio_coord_draw_c / 100
          );

          min.min(position);
          max.max(position);
        });

        const center = new THREE.Vector3(
          (min.x + max.x) / 2,
          (min.y + max.y) / 2,
          (min.z + max.z) / 2
        );

        return { min, max, center };
      }

      function createWall(position, size) {
        const geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
        const material = new THREE.MeshLambertMaterial({ color: 0xd1d1d1 });
        const wall = new THREE.Mesh(geometry, material);
        wall.position.copy(position);
        wall.castShadow = true;
        wall.receiveShadow = true;
        scene.add(wall);
        worldOctree.fromGraphNode(wall);
      }

      // F2 change parameter name in all document
      // Create walls around the bounding box with a margin
      function createWallsAroundRacks(wallBoundingBoxCoords) {
        const min = wallBoundingBoxCoords.min;
        const max = wallBoundingBoxCoords.max;

        // Parâmetros das paredes
        const wallHeight = 5;
        const wallThickness = 0.01;
        const wallMargin = 10; // Adjust this value to set the margin

        // Calculate adjusted min and max with margin
        const adjustedMin = new THREE.Vector3(
          min.x - wallMargin,
          min.y,
          min.z - wallMargin
        );
        const adjustedMax = new THREE.Vector3(
          max.x + wallMargin,
          max.y,
          max.z + wallMargin
        );

        // Calculate wall positions and sizes
        const frontWallPosition = new THREE.Vector3(
          (adjustedMin.x + adjustedMax.x) / 2,
          wallHeight / 2,
          adjustedMin.z - wallThickness / 2
        );
        const backWallPosition = new THREE.Vector3(
          (adjustedMin.x + adjustedMax.x) / 2,
          wallHeight / 2,
          adjustedMax.z + wallThickness / 2
        );
        const leftWallPosition = new THREE.Vector3(
          adjustedMin.x - wallThickness / 2,
          wallHeight / 2,
          (adjustedMin.z + adjustedMax.z) / 2
        );
        const rightWallPosition = new THREE.Vector3(
          adjustedMax.x + wallThickness / 2,
          wallHeight / 2,
          (adjustedMin.z + adjustedMax.z) / 2
        );

        const wallWidth = adjustedMax.x - adjustedMin.x + wallThickness;
        const wallDepth = adjustedMax.z - adjustedMin.z + wallThickness;

        // Create four walls
        createWall(
          frontWallPosition,
          new THREE.Vector3(wallWidth, wallHeight, wallThickness)
        );
        createWall(
          backWallPosition,
          new THREE.Vector3(wallWidth, wallHeight, wallThickness)
        );
        createWall(
          leftWallPosition,
          new THREE.Vector3(wallThickness, wallHeight, wallDepth)
        );
        createWall(
          rightWallPosition,
          new THREE.Vector3(wallThickness, wallHeight, wallDepth)
        );

        // Create floor
        const floorGeometry = new THREE.PlaneGeometry(wallWidth, wallDepth);
        //Mudança das Cores GM
        const floorMaterial = new THREE.MeshLambertMaterial({
          color: 0x30384f,
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(
          (adjustedMin.x + adjustedMax.x) / 2,
          0,
          (adjustedMin.z + adjustedMax.z) / 2
        );
        floor.receiveShadow = true;
        scene.add(floor);
        worldOctree.fromGraphNode(floor);
      }

      // Update createWalls function to use bounding box
      function createWalls(wallBoundingBoxCoords) {
        if (racks && racks.length > 0) {
          createWallsAroundRacks(wallBoundingBoxCoords);
        }
      }

      // Calcula se algum vetor interseta com um bounding box
      function playerCollisions() {
        const result = worldOctree.capsuleIntersect(playerCollider);
        playerOnFloor = false;

        if (result) {
          playerOnFloor = result.normal.y > 0;

          if (!playerOnFloor) {
            playerVelocity.addScaledVector(
              result.normal,
              -result.normal.dot(playerVelocity)
            );
          }

          playerCollider.translate(result.normal.multiplyScalar(result.depth));
        }
      }

      // Atualizar o player a cada frame (colisões, velocidade)
      function updatePlayer(deltaTime) {
        let damping = Math.exp(-4 * deltaTime) - 1;

        if (!playerOnFloor) {
          playerVelocity.y -= GRAVITY * deltaTime;
          damping *= 0.1;
        }

        playerVelocity.addScaledVector(playerVelocity, damping);

        const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
        playerCollider.translate(deltaPosition);

        // colisões
        playerCollisions();

        camera.position.copy(playerCollider.end);
        camera.position.copy(playerCollider.end);

        // Evita que a câmera continue a olhar para baixo após colisões
        if (!document.pointerLockElement) {
          camera.rotation.set(0, 0, 0); // só se não estiver no modo pointerlock
        }

        // Clamp player position inside warehouse bounds
      }

      function getForwardVector() {
        camera.getWorldDirection(playerDirection);
        playerDirection.y = 0;
        playerDirection.normalize();
        return playerDirection;
      }

      function getSideVector() {
        camera.getWorldDirection(playerDirection);
        playerDirection.y = 0;
        playerDirection.normalize();
        playerDirection.cross(camera.up);
        return playerDirection;
      }

      // Ativar movimentos com as teclas
      function handleControls(deltaTime) {
        const speedDelta = deltaTime * (playerOnFloor ? 25 : 8);

        if (activeCamera === camera) {
          if (keyStates["KeyW"]) {
            playerVelocity.add(getForwardVector().multiplyScalar(speedDelta));
          }

          if (keyStates["KeyS"]) {
            playerVelocity.add(getForwardVector().multiplyScalar(-speedDelta));
          }

          if (keyStates["KeyA"]) {
            playerVelocity.add(getSideVector().multiplyScalar(-speedDelta));
          }

          if (keyStates["KeyD"]) {
            playerVelocity.add(getSideVector().multiplyScalar(speedDelta));
          }

          if (playerOnFloor) {
            if (keyStates["Space"]) {
              playerVelocity.y = 15;
            }
          }
        }
      }

      // wtv
      const helper = new OctreeHelper(worldOctree);
      helper.visible = false;
      scene.add(helper);

      // wtv
      // const gui = new GUI({ width: 200 });
      // gui.add({ debug: false }, "debug").onChange(function (value) {
      //   helper.visible = value;
      // });

      // Se o personagem foge do mapa ele volta
      function teleportPlayerIfOob() {
        if (camera.position.y <= -25) {
          playerCollider.start.set(
            boundingBoxCenter.x,
            boundingBoxCenter.y + 0.35,
            boundingBoxCenter.z
          );
          playerCollider.end.set(
            boundingBoxCenter.x,
            boundingBoxCenter.y + 1,
            boundingBoxCenter.z
          );
          playerCollider.radius = 0.35;
          camera.position.copy(playerCollider.end);
          camera.rotation.set(0, Math.PI, 0); // reinicia com rotação para frente
          playerVelocity.set(0, 0, 0); // zera velocidade também
        }
      }

      // Alterar entre camaras
      function toggleCamera() {
        activeCamera = activeCamera === camera ? topCamera : camera;

        if (employeeModel) {
          employeeModel.position.copy(playerCollider.end);
          employeeModel.visible = activeCamera === topCamera;
        }

        if (activeCamera === camera) {
          document.body.requestPointerLock();
        } else {
          document.exitPointerLock();
        }
        orbitControls.target.copy(playerCollider.end);
      }

      const orbitControls = new OrbitControls(topCamera, renderer.domElement);
      //orbitControls.target.set(45, 10, 79.49);
      orbitControls.screenSpacePanning = true;
      orbitControls.minDistance = 1;
      orbitControls.maxDistance = 10000;
      orbitControls.maxPolarAngle = Math.PI / 2;
      orbitControls.enablePan = true;
      orbitControls.enableDamping = true;
      orbitControls.enabled = true;
      orbitControls.dampingFactor = 0.05;

      // Atualização da cena
      function animate() {
        const deltaTime = Math.min(0.05, clock.getDelta()) / STEPS_PER_FRAME;

        for (let i = 0; i < STEPS_PER_FRAME; i++) {
          handleControls(deltaTime);
          updatePlayer(deltaTime);
          teleportPlayerIfOob();
        }

        if (employeeModel) {
          // Toggle visibility of employee based on active camera
          employeeModel.visible = true;
          employeeModel.position.copy(playerCollider.end);
        }

        if (activeCamera === topCamera) {
          moveTopCamera(deltaTime * 60);
          orbitControls.update();
        }
        if (activeCamera === camera) {
          const maxPitch = Math.PI / 2 - 0.1;
          const minPitch = -Math.PI / 2 + 0.1;
          camera.rotation.x = Math.max(
            minPitch,
            Math.min(maxPitch, camera.rotation.x)
          );
        }

        renderer.render(scene, activeCamera);
        stats.update();
      }

      async function createRacksFromJSON(racks, buffers) {
        const tolerance = 0.5;

        // Group racks by X and Z to avoid drawing duplicates
        const rackMap = new Map();

        racks.forEach((rack) => {
          const x = parseFloat(rack.Spazio_coord_draw_a) / 100;
          const z = parseFloat(rack.Spazio_coord_draw_c) / 100;
          const key = `${x.toFixed(2)}|${z.toFixed(2)}`;

          if (!rackMap.has(key)) {
            rackMap.set(key, []);
          }
          rackMap.get(key).push(rack);
        });

        rackMap.forEach((rackGroupData, key) => {
          const [xRack, zRack] = key.split("|").map(parseFloat);

          // Find all buffers at this rack position (same X/Z)
          const buffersAbove = buffers.filter((buffer) => {
            const x = parseFloat(buffer.Spazio_coord_draw_a) / 100;
            const z = parseFloat(buffer.Spazio_coord_draw_c) / 100;
            return (
              Math.abs(x - xRack) <= tolerance &&
              Math.abs(z - zRack) <= tolerance
            );
          });

          if (buffersAbove.length === 0) return;

          // Lowest Y value from the group of racks (rack base)
          const yBase =
            Math.min(
              ...rackGroupData.map((r) => parseFloat(r.Spazio_coord_draw_b))
            ) / 100;

          // Use first rack in group for dimensions
          const refRack = rackGroupData[0];
          const width = parseFloat(refRack.Spazio_coord_largo || 120) / 100;
          const height = parseFloat(refRack.Spazio_coord_alto || 925) / 100;
          const depth = parseFloat(refRack.Spazio_coord_fondo || 320) / 100;

          // Create the rack mesh
          const geometry = new THREE.BoxGeometry(width, height, depth);
          const material = new THREE.MeshBasicMaterial({
            color: 0x5865f2,
            transparent: true,
            opacity: 0.2,
          });

          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.set(
            xRack + width / 2,
            yBase + height / 2,
            zRack + depth / 2
          );
          mesh.name = "Rack";
          mesh.userData.isRack = true;

          rackGroup.add(mesh); //
          rackMeshes.push(mesh);

          // Add white outline
          const edges = new THREE.EdgesGeometry(geometry);
          const line = new THREE.LineSegments(
            edges,
            new THREE.LineBasicMaterial({ color: 0xffffff })
          );
          line.position.copy(mesh.position);
          rackGroup.add(line);
        });

        console.log(`Racks created: ${rackMap.size}`);
      }

      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      let hoveredRack = null;

      function isFullyVisible(obj) {
        if (!obj.visible) return false;
        let parent = obj.parent;
        while (parent) {
          if (!parent.visible) return false;
          parent = parent.parent;
        }
        return true;
      }
      function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, activeCamera);
        const hoverTargets = [
          ...rackMeshes,
          ...dockMeshes,
          ...stackMeshes,
          ...corridorMeshes,
          ...driveInMeshes,
        ];

        // ✅ Só considerar objetos visíveis
        const visibleTargets = hoverTargets.filter(isFullyVisible);
        const intersects = raycaster.intersectObjects(visibleTargets);

        if (intersects.length > 0) {
          const first = intersects[0].object;

          if (hoveredRack !== first) {
            hoveredRack = first;
            document.body.style.cursor = "pointer";
          }

          tooltip.style.left = event.clientX + 10 + "px";
          tooltip.style.top = event.clientY + 10 + "px";
          const pos = first.position;
          let type = "Objeto";
          if (rackMeshes.includes(first)) type = "Rack";
          else if (dockMeshes.includes(first)) type = "Cais";
          else if (stackMeshes.includes(first)) type = "Pilha";
          else if (corridorMeshes.includes(first)) type = "Corredor";
          else if (driveInMeshes.includes(first)) type = "DriveIn";

          tooltip.innerHTML = `<strong>${type}</strong><br>
    <strong>X</strong>: ${pos.x.toFixed(2)} 
    <strong>Y</strong>: ${pos.y.toFixed(2)} 
    <strong>Z</strong>: ${pos.z.toFixed(2)}`;
          tooltip.style.display = "block";
        } else {
          hoveredRack = null;
          document.body.style.cursor = "default";
          tooltip.style.display = "none";
        }
      }

      window.addEventListener("mousemove", onMouseMove);

      const topCamMoveSpeed = 5;

      function moveTopCamera(deltaTime) {
        const speed = topCamMoveSpeed * deltaTime;

        const forward = new THREE.Vector3();
        topCamera.getWorldDirection(forward);
        forward.y = 0;
        forward.normalize();

        const right = new THREE.Vector3();
        right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

        const move = new THREE.Vector3();

        if (keyStates["KeyW"]) move.add(forward); // Forward
        if (keyStates["KeyS"]) move.sub(forward); // Backward
        if (keyStates["KeyD"]) move.add(right); // Right
        if (keyStates["KeyA"]) move.sub(right); // Left

        move.normalize().multiplyScalar(speed);

        topCamera.position.add(move);
        // After moving camera
        employeeModel.position.copy(topCamera.position);

        orbitControls.target.add(move);
      }
      // cria um cubo que representa a posição do empregado
      function createEmployee() {
        const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.6); // Adjust size as needed
        const material = new THREE.MeshLambertMaterial({ color: 0xff0000 }); // Adjust color and material as needed
        employeeModel = new THREE.Mesh(geometry, material);
        employeeModel.position.copy(playerCollider.end); // Position the cube where the employee model would be
        employeeModel.visible = false; // Initially hide the cube
        scene.add(employeeModel);
      }

      // Function to create spaces from JSON data using InstancedMesh ISTO É O PICKING BASICAMENTE MAS A AVERIGUAR
      function createSpacesFromJSON() {
        const spaceColor = 0x00ff00;
        const spaceOpacity = 0.95;
        const shrinkFactor = 0.65;

        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshBasicMaterial({
          color: spaceColor,
          transparent: true,
          opacity: spaceOpacity,
        });

        const instancedMesh = new THREE.InstancedMesh(
          geometry,
          material,
          spaces.length
        );
        const dummy = new THREE.Object3D();

        spaces.forEach((space, i) => {
          const x = parseFloat(space.Spazio_coord_draw_a) / 100;
          const y = parseFloat(space.Spazio_coord_draw_b) / 100;
          const z = parseFloat(space.Spazio_coord_draw_c) / 100;

          const width = parseFloat(space.Spazio_coord_largo || 80) / 100;
          const height = parseFloat(space.Spazio_coord_alto || 180) / 100;
          const depth = parseFloat(space.Spazio_coord_fondo || 120) / 100;

          const px = x + width / 2;
          const py = y + height / 2;
          const pz = z + depth / 2;

          dummy.position.set(px, py, pz);
          dummy.scale.set(
            width * shrinkFactor,
            height * shrinkFactor,
            depth * shrinkFactor
          );

          dummy.updateMatrix();
          instancedMesh.setMatrixAt(i, dummy.matrix);
        });

        spaceGroup.add(instancedMesh);
        console.log(`Spaces created: ${spaces.length}`);
      }

      // Create geometry and material for cubes
      /*const cubeGeometry = new THREE.BoxGeometry(1, 1, 1); // 1x1x1 cubes
        const cubeMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 }); // Red color

        const count = spaces.length; // Assuming spaces is an array of data

        // Create InstancedMesh with cube geometry and material
        instancedMesh = new THREE.InstancedMesh(
          cubeGeometry,
          cubeMaterial,
          count
        );

        const dummy = new THREE.Object3D();

        spaces.forEach((item, i) => {
          const position = new THREE.Vector3(
            item.Spazio_coord_draw_a / 50,
            item.Spazio_coord_draw_b / 50,
            item.Spazio_coord_draw_c / 50
          );

          // Set position only, no rotation or scaling
          dummy.position.copy(position);
          dummy.rotation.set(0, 0, 0); // No rotation
          dummy.scale.set(1, 1, 1); // Default scale
          dummy.updateMatrix();
          instancedMesh.setMatrixAt(i, dummy.matrix);
        });

        instancedMesh.castShadow = true;
        instancedMesh.receiveShadow = true;
        scene.add(instancedMesh);

        // Add the InstancedMesh to the Octree
        worldOctree.fromGraphNode(instancedMesh); */

      //Create buffers from the JSON -> GM ALTERAÇÃO FUNÇAO CREATEBUFFERFROMJSON
      //Create buffers from the JSON -> GM ALTERAÇÃO FUNÇAO CREATEBUFFERFROMJSON
      function createBufferFromJSON(bufferArray) {
        const bufferColor = 0xd48c8c;
        const bufferOpacity = 0.95;
        const shrinkFactor = 0.65;

        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshBasicMaterial({
          color: bufferColor,
          transparent: true,
          opacity: bufferOpacity,
        });

        const count = bufferArray.length;
        const instancedMesh = new THREE.InstancedMesh(
          geometry,
          material,
          count
        );
        const dummy = new THREE.Object3D();

        bufferArray.forEach((item, i) => {
          const x = parseFloat(item.Spazio_coord_draw_a) / 100;
          const y = parseFloat(item.Spazio_coord_draw_b) / 100;
          const z = parseFloat(item.Spazio_coord_draw_c) / 100;

          const largura = parseFloat(item.Spazio_coord_largo || 80) / 100;
          const altura = parseFloat(item.Spazio_coord_alto || 180) / 100;
          const profundidade = parseFloat(item.Spazio_coord_fondo || 120) / 100;

          const scaleX = largura * shrinkFactor;
          const scaleY = altura * shrinkFactor;
          const scaleZ = profundidade * shrinkFactor;

          dummy.position.set(
            x + largura / 2,
            y + altura / 2,
            z + profundidade / 2
          );
          dummy.rotation.set(0, 0, 0);
          dummy.scale.set(scaleX, scaleY, scaleZ);
          dummy.updateMatrix();

          instancedMesh.setMatrixAt(i, dummy.matrix);
        });

        bufferGroup.add(instancedMesh);
        console.log(`Buffers desenhados: ${count}`);
      }

      async function extractDataFromJSON(data) {
        racks = data.Racks;
        spaces = data.Spaces;
        wallBoundingBoxCoords = calculateWallBoundingBox(data.Racks);
        boundingBoxCenter.copy(wallBoundingBoxCoords.center);

        // coloca o collider do player ligeiramente acima do chão para evitar colisão imediata
        playerCollider.start.set(
          boundingBoxCenter.x,
          0.35,
          boundingBoxCenter.z
        );
        playerCollider.end.set(boundingBoxCenter.x, 1, boundingBoxCenter.z);

        // atualiza também a posição e rotação da câmera para garantir que começa corretamente
        camera.position.copy(playerCollider.end);
        camera.rotation.set(0, Math.PI, 0); // Olha para "frente" (ajusta se necessário)

        // Set the topCamera position to the center of the bounding box
        orbitControls.target.set(boundingBoxCenter.x, 50, boundingBoxCenter.z);

        await createRacksFromJSON(racks, data.Buffer);
        await createSpacesFromJSON();
        createWalls(wallBoundingBoxCoords);
        createEmployee();
      }
      //Nova função realizada por GM para representar os espaços
      function createCorridorsFromJSON(corridors) {
        const height = 0.01;
        const corridorMaterial = new THREE.MeshBasicMaterial({
          color: 0x3399ff,
          transparent: true,
          opacity: 0.2,
        });

        corridors.forEach((corridor) => {
          const x = parseFloat(corridor.Spazio_coord_draw_a) / 100;
          const z = parseFloat(corridor.Spazio_coord_draw_c) / 100;

          // Largura do corredor (ajustada ao tamanho visual da rack)
          const width = 4; // mesma largura que usas nas racks
          const depth = 2; // mesma profundidade que usas nas racks

          const geometry = new THREE.PlaneGeometry(width, depth);
          const mesh = new THREE.Mesh(geometry, corridorMaterial);
          mesh.rotation.x = -Math.PI / 2;

          // Posiciona o plano centrado como as racks
          mesh.position.set(x, height, z);
          corridorGroup.add(mesh);
          corridorMeshes.push(mesh);
        });

        console.log(`Corredores desenhados: ${corridors.length}`);
      }

      //FUNÇÃO PARA CRIAÇÃO DE CAIS ALTERAÇÃO GM
      async function createDockFromJSON(docks) {
        docks.forEach((dock) => {
          const x = parseFloat(dock.Spazio_coord_draw_a) / 100;
          const z = parseFloat(dock.Spazio_coord_draw_c) / 100;

          const width = parseFloat(dock.Spazio_coord_largo) / 100;
          const depth = parseFloat(dock.Spazio_coord_fondo) / 100;

          const geometry = new THREE.BoxGeometry(width, 0, depth);
          const material = new THREE.MeshStandardMaterial({
            color: dock.cor || "#ffa500",
            transparent: true,
            opacity: 0.9,
            depthWrite: true,
          });

          const mesh = new THREE.Mesh(geometry, material);

          // Y mínimo para aparecer no chão mas sem afundar
          mesh.position.set(x + width / 2, 0, z + depth / 2);

          dockGroup.add(mesh);

          const edges = new THREE.EdgesGeometry(geometry);
          const line = new THREE.LineSegments(
            edges,
            new THREE.LineBasicMaterial({ color: 0xffffff })
          );
          line.position.copy(mesh.position);
          dockMeshes.push(mesh);

          dockGroup.add(line);
        });
      }

      //ESTA FUNÇA USADA PARA GERAR AS PILHAS -> GM ALTERAÇÃO
      async function createStacksFromJSON(stacks) {
        const stackColor = 0x9966ff;
        const stackOpacity = 0.95;
        const boxHeight = 0.6; // altura de cada caixa empilhada (em metros)

        stacks.forEach((stack) => {
          const x = parseFloat(stack.Spazio_coord_draw_a) / 100;
          const y = parseFloat(stack.Spazio_coord_draw_b) / 100;
          const z = parseFloat(stack.Spazio_coord_draw_c) / 100;

          const width = parseFloat(stack.Spazio_coord_largo) / 100;
          const height = parseFloat(stack.Spazio_coord_alto) / 100;
          const depth = parseFloat(stack.Spazio_coord_fondo) / 100;

          const numBoxes = Math.floor(height / boxHeight);
          const geometry = new THREE.BoxGeometry(width, boxHeight, depth);
          const material = new THREE.MeshBasicMaterial({
            color: stack.color || stackColor,
            transparent: true,
            opacity: stackOpacity,
          });

          for (let i = 0; i < numBoxes; i++) {
            const box = new THREE.Mesh(geometry, material);
            box.position.set(
              x + width / 2,
              y + boxHeight / 2 + i * boxHeight,
              z + depth / 2
            );
            box.userData.type = "Pilha"; // ✅ define o tipo corretamente

            stackGroup.add(box);
            stackMeshes.push(box); // ✅ necessário para o hover funcionar

            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(
              edges,
              new THREE.LineBasicMaterial({ color: 0xffffff })
            );
            line.position.copy(box.position);
            stackGroup.add(line);
          }

          // Adiciona 4 linhas verticais na frente e atrás para visual
          for (let i = 1; i < 4; i++) {
            const offset = (width / 4) * i;

            const geometryFront = new THREE.BufferGeometry().setFromPoints([
              new THREE.Vector3(x + offset, y, z),
              new THREE.Vector3(x + offset, y + height, z),
            ]);
            const lineFront = new THREE.Line(
              geometryFront,
              new THREE.LineBasicMaterial({ color: 0xffffff })
            );
            stackGroup.add(lineFront);

            const geometryBack = new THREE.BufferGeometry().setFromPoints([
              new THREE.Vector3(x + offset, y, z + depth),
              new THREE.Vector3(x + offset, y + height, z + depth),
            ]);
            const lineBack = new THREE.Line(
              geometryBack,
              new THREE.LineBasicMaterial({ color: 0xffffff })
            );
            stackGroup.add(lineBack);
          }
        });

        console.log(`Pilhas desenhadas: ${stacks.length}`);
      }

      //ESTA FUNÇÃO É USADA PARA GERAR DRIVE-INS
      async function createDriveInsFromJSON(driveIns) {
        driveIns.forEach((driveIn) => {
          const x = parseFloat(driveIn.Spazio_coord_draw_a) / 100;
          const y = parseFloat(driveIn.Spazio_coord_draw_b) / 100;
          const z = parseFloat(driveIn.Spazio_coord_draw_c) / 100;

          const width = parseFloat(driveIn.Spazio_coord_largo) / 100;
          const height = parseFloat(driveIn.Spazio_coord_alto) / 100;
          const depth = parseFloat(driveIn.Spazio_coord_fondo) / 100;

          const geometry = new THREE.BoxGeometry(width, height, depth);
          const material = new THREE.MeshBasicMaterial({
            color: driveIn.cor || "#00ccff",
            transparent: true,
            opacity: 0.95,
            depthWrite: true,
          });

          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.set(x + width / 2, y + height / 2, z + depth / 2);
          driveInGroup.add(mesh);

          const edges = new THREE.EdgesGeometry(geometry);
          const line = new THREE.LineSegments(
            edges,
            new THREE.LineBasicMaterial({ color: 0xffffff })
          );

          line.position.copy(mesh.position);
          driveInMeshes.push(mesh);

          driveInGroup.add(line);
        });

        console.log(`Drive-ins desenhados: ${driveIns.length}`);
      }
      // Fetch JSON data and start rendering
      window.onload = function () {
        fetch("resources/data/armcarlos.json")
          .then((response) => response.json())
          .then(async (data) => {
            await extractDataFromJSON(data);
            createCorridorsFromJSON(data.Corridor); // -> Alteração GM
            createBufferFromJSON(data.Buffer); // -> Alteração GM
            createDockFromJSON(data.Cais); // -> Alteração GM
            createStacksFromJSON(data.Pilhas); // -> Alteração GM
            createDriveInsFromJSON(data.DriveIn); // -> Alteração GM
            //ALTERAÇAO GM
            // Adicionar o GridHelper com base no tamanho real do armazém
            const largura =
              wallBoundingBoxCoords.max.x - wallBoundingBoxCoords.min.x + 20;
            const profundidade =
              wallBoundingBoxCoords.max.z - wallBoundingBoxCoords.min.z + 20;
            const gridSize = Math.max(largura, profundidade);
            const gridDivisions = Math.floor(gridSize / 5);

            const gridHelper = new THREE.GridHelper(
              gridSize,
              gridDivisions,
              0x555a66,
              0x555a66
            );
            gridHelper.position.set(
              wallBoundingBoxCoords.center.x,
              0.01,
              wallBoundingBoxCoords.center.z
            );
            scene.add(gridHelper);
          })
          .catch((error) => console.error("Error fetching JSON:", error));
      };

      function isNotHidden(obj) {
        if (obj.userData.hidden) return false;
        let parent = obj.parent;
        while (parent) {
          if (parent.userData && parent.userData.hidden) return false;
          parent = parent.parent;
        }
        return true;
      }
    </script>
  </body>
</html>
