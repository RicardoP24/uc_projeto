<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <title>three.js - misc - octree collisions</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link rel="stylesheet" href="three/ISRWarehouse3D/warehouse3DGMRS.css" />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <div id="loader" class="loader-overlay">
  <div class="loader-content">
    <img src="three/ISRWarehouse3D/imgs/fade-stagger-circles.svg" alt="loading" class="loader-icon" />
    
  </div>
</div>
    <!-- HEADER NAVIGATION -->
    <div id="top-nav">
      <div class="nav-left">
        <img src="three/ISRWarehouse3D/imgs/Eve_Icon.png" class="logo" />
        <span class="title">Warehouse 3D</span>
      </div>
      <div class="nav-right">
        <button id="toggleWarehouseBtn" title="Show Warehouse">
           <img src ="three/ISRWarehouse3D/imgs/warehouse-light.svg" class="phosphor-icon"/>
           </button>
        <button id="toggle-view-btn">2D</button>
        <button id="tutorial-btn">Tutorial</button>
      </div>
    </div>

    <div id="tutorial-tooltip">
      <strong>Controlers:</strong><br />
      "MOUSE 1" to look around <br />
      "WASD" to move <br />
      "T" to toggle freecam <br />
      "MOUSE SCROLL" to amplify
    </div>
    <div id="zoom-controls">
      <button id="zoom-in">+</button>
      <button id="zoom-out">−</button>
      <button id="reset-topcam">↺</button>
    </div>
    <!-- END OF HEADER NAVIGATION -->
    <div id="legend-popup" class="legend-popup hidden" draggable="true"></div>

    <div
      id="tooltip"
      style="
        position: absolute;
        color: white;
        background: rgba(0, 0, 0, 0.8);
        padding: 6px 10px;
        border-radius: 5px;
        font-size: 14px;
        pointer-events: none;
        z-index: 999;
        display: none;
        font-family: sans-serif;
      "
    ></div>

    <div id="container"></div>
    <button id="sidebar-toggle">❮</button>

    <!-- Sidebar HTML -->
    <div id="sidebar">
      <h2  id="ArmName" class="arm"></h2>
      <div id="sidebar-dynamic-container"></div>

      <!-- CHECKBOX CAPTIONS SIMPLES E ALINHADO -->
      <details class="dropdown-group" open>
        <summary id="toggle-captions-btn">
          <span style="display: flex; align-items: center; gap: 6px">
            <img src="three/ISRWarehouse3D/imgs/warehouse-light.svg" class="phosphor-icon">
            <span>TOGGLE CAPTIONS</span>
          </span>
        </summary>
      </details>

      

    <!-- FIM DO HTML DO SIDEBAR-->

    <script type="importmap">
      {
        "imports": {
          "three": "./three/build/three.module.js",
          "three/addons/": "./three/examples/jsm/"
        }
      }
    </script>
    
    <script type="module">
      import * as THREE from "three";
      import Stats from "three/addons/libs/stats.module.js";
      import { Octree } from "three/addons/math/Octree.js";
      import { OctreeHelper } from "three/addons/helpers/OctreeHelper.js";
      import { Capsule } from "three/addons/math/Capsule.js";
      import { GUI } from "three/addons/libs/lil-gui.module.min.js";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import {
        CSS2DRenderer,
        CSS2DObject,
      } from "./three/examples/jsm/renderers/CSS2DRenderer.js";

 const traduções = {
  Arm: {
    PT: "Armazém 3D",
    BR: "Armazém 3D",
    EN: "Warehouse 3D",
    IT: "Magazzino 3D",
    ES: "Almacén 3D",
    PL: "Magazyn 3D",
    EL: "Warehouse 3D"
  },
  Tut: {
    PT: "Tutorial",
    BR: "Tutorial",
    EN: "Tutorial",
    IT: "Tutorial",
    ES: "Tutorial",
    PL: "Samouczek",
    EL: "Οδηγός"
  },
  Ctrls: {
    PT: "Controles",
    BR: "Controles",
    EN: "Controllers",
    IT: "Controlli",
    ES: "Controles",
    PL: "Sterowanie",
    EL: "Χειριστήρια"
  },
  MouseLook: {
    PT: "\"MOUSE 1\" para olhar em redor",
    BR: "\"MOUSE 1\" para olhar ao redor",
    EN: "\"MOUSE 1\" to look around",
    IT: "\"MOUSE 1\" per guardarti intorno",
    ES: "\"MOUSE 1\" para mirar alrededor",
    PL: "\"MOUSE 1\" – rozglądanie się",
    EL: "\"MOUSE 1\" για να κοιτάξεις γύρω"
  },
  WASD: {
    PT: "\"WASD\" para mover",
    BR: "\"WASD\" para mover",
    EN: "\"WASD\" to move",
    IT: "\"WASD\" per muovere",
    ES: "\"WASD\" para moverte",
    PL: "\"WASD\" – poruszanie się",
    EL: "\"WASD\" για μετακίνηση"
  },
  Freecam: {
    PT: "\"T\" para alternar câmara livre",
    BR: "\"T\" para alternar freecam",
    EN: "\"T\" to toggle freecam",
    IT: "\"T\" per attivare/disattivare la freecam",
    ES: "\"T\" para alternar freecam",
    PL: "\"T\" – przełącz tryb freecam",
    EL: "\"T\" για εναλλαγή freecam"
  },
  Scroll: {
    PT: "\"SCROLL\" do rato para ampliar",
    BR: "\"SCROLL\" do mouse para ampliar",
    EN: "\"MOUSE SCROLL\" to amplify",
    IT: "\"SCROLL\" del mouse per ampliare",
    ES: "\"SCROLL\" del ratón para ampliar",
    PL: "\"PRZEWIJANIE MYSZĄ\" – przybliżanie",
    EL: "\"ΚΥΛΙΣΗ ΠΟΝΤΙΚΙΟΥ\" για μεγέθυνση"
  },
  ToggleCaptions: {
    PT: "Alternar Legendas",
    BR: "Alternar Legendas",
    EN: "TOGGLE CAPTIONS",
    IT: "Mostra/Nasconde didascalie",
    ES: "Alternar Subtítulos",
    PL: "Przełącz napisy",
    EL: "Εναλλαγή λεζάντων"
  },
  Layout: {
    PT: "Layout",
    BR: "Layout",
    EN: "Layout",
    IT: "Layout",
    ES: "Diseño",
    PL: "Układ",
    EL: "Διάταξη"
  },
  Availability: {
    PT: "Verificar Disponibilidade",
    BR: "Verificar Disponibilidade",
    EN: "Check Availability",
    IT: "Verifica Disponibilità",
    ES: "Comprobar Disponibilidad",
    PL: "Sprawdź dostępność",
    EL: "Έλεγχος διαθεσιμότητας"
  },
  Flatten2D: {
    PT: "Achatar Altura (2D)",
    BR: "Achatar Altura (2D)",
    EN: "Flatten Height (2D)",
    IT: "Appiattisci Altezza (2D)",
    ES: "Aplanar Altura (2D)",
    PL: "Spłaszcz wysokość (2D)",
    EL: "Επίπεδο ύψους (2D)"
  },
  Label: {
    PT: "Etiqueta",
    BR: "Rótulo",
    EN: "Label",
    IT: "Etichetta",
    ES: "Etiqueta",
    PL: "Etykieta",
    EL: "Ετικέτα"
  },
  Levels: {
    PT: "Níveis",
    BR: "Níveis",
    EN: "Levels",
    IT: "Livelli",
    ES: "Niveles",
    PL: "Poziomy",
    EL: "Επίπεδα"
  }
};



      const clock = new THREE.Clock();
      let wallBoundingBoxCoords;
      let racks;
      let spaces;
      let docks;
      let stacks;
      let driveIns;
      let corredor;
      let buffers;
      let boundingBoxCenter = new THREE.Vector3();
      let classeEspExecMeshes = []; // Add this at the top of your script
      let classeEspArmMeshes = [];
      let classeCaisMeshes = [];
      let classeDivEspacosMeshes = [];
      let classeZonAnomalasMeshes = [];
      let classeEspacoDistrMeshes = [];
      let classeTransportesMeshes = [];
      let classeTransicaoMeshes = [];
      let classePilhaMeshes = [];
      let classeCaisTemporarioMeshes = [];
      let isWarehouseVisible = false;
      const originalScalesByClasse = {
        "01": {},
        "02": {},
        "03": {},
        "04": {},
        "05": {},
        "06": {},
        "08": {},
        "09": {},
        "10": {},
      };
      const EspacosPorTipoD = {};
      const outlinesArray = [];
      let EspacosAll = [];
      let hoveredInstance = null; // guarda instância ativa no hover

      const bufferOriginalScales = {}; // índice → escala real
      
      const scene = new THREE.Scene();
      //Mudança das core GM
      scene.background = new THREE.Color(0x252c3f);

      let instancedMesh;
      let bufferInstancedMesh = null;

      const camera = new THREE.PerspectiveCamera(
        70,
        window.innerWidth / window.innerHeight,
        0.1,
        10000
      );
      camera.position.set(50, 1, 50); // ou boundingBoxCenter quando disponível
      camera.rotation.set(0, 0, 0); // olhe para frente
      camera.up.set(0, 1, 0);

      camera.rotation.order = "YXZ";

      const topCamera = new THREE.PerspectiveCamera(
        20,
        window.innerWidth / window.innerHeight,
        1,
        10000
      );

      topCamera.position.set(50, 100, 50); // Starting high above the warehouse
      const initialTopCamPosition = new THREE.Vector3(50, 100, 50);
      const initialTopCamTarget = new THREE.Vector3(50, 0, -50);

      const angle = Math.PI; // 180 degrees

      const offset = new THREE.Vector3().subVectors(
        initialTopCamPosition,
        initialTopCamTarget
      );
      offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle); // rotate offset around Y

      const rotatedPosition = new THREE.Vector3().addVectors(
        initialTopCamTarget,
        offset
      );

      // Apply rotated position to topCamera
      topCamera.position.copy(rotatedPosition);
      topCamera.lookAt(initialTopCamTarget);
      
      // ---------- ORTHO (2D) CAMERA ----------
      const ORTHO_SIZE = 120; // “altura” do frustum – ajuste se necessário
      const aspect = window.innerWidth / window.innerHeight;

      const orthoCamera = new THREE.OrthographicCamera(
        (-ORTHO_SIZE * aspect) / 2, // left
        (ORTHO_SIZE * aspect) / 2, // right
        ORTHO_SIZE / 2, // top
        -ORTHO_SIZE / 2, // bottom
        1, // near
        10000 // far
      );
      orthoCamera.position.copy(rotatedPosition); // mesmo ponto de vista
      orthoCamera.lookAt(new THREE.Vector3(50, 0, -50)); // mesmo alvo

      const toggleViewBtn = document.getElementById("toggle-view-btn");
      let is2DView = false;

      toggleViewBtn.addEventListener("click", () => {
        is2DView = !is2DView;

        if (is2DView) {
          // Troca para ortográfica

          orthoCamera.position.copy(initialTopCamPosition);
          orthoCamera.lookAt(initialTopCamTarget);
          activeCamera = orthoCamera;
          toggleViewBtn.textContent = "3D";
          orbitControls.enableRotate = true;
        } else {
          // Volta para a topCamera
          activeCamera = topCamera;
          toggleViewBtn.textContent = "2D";
          orbitControls.enableRotate = true;
        }

        orbitControls.object = activeCamera;
        orbitControls.update();
      });

      // Zoom control logic
      const zoomInBtn = document.getElementById("zoom-in");
      const zoomOutBtn = document.getElementById("zoom-out");

      let activeCamera = camera;

      //Resetar a top camera ao default
      const resetTopCamBtn = document.getElementById("reset-topcam");

      const viewCheckboxes = document.querySelectorAll(
      `#sidebar input[type="checkbox"]`
      );

 
  
      //FUNCTION formatSpazioLabel(spazio) MADE MY GM
      function formatSpazioLabel(spazio) {
        const s = String(spazio).padStart(4, "0");
        return `${s.slice(0, 2)}.${s.slice(2)}`;
      }

      resetTopCamBtn.addEventListener("click", () => {
        if (activeCamera === topCamera) {
          topCamera.position.copy(rotatedPosition);
          topCamera.lookAt(initialTopCamTarget);
          // orbitControls.target.copy(initialTopCamTarget);
          employeeModel.position.copy(rotatedPosition);
        }
      });

      // Aumentar a illuminação Global ALTERAÇÃO GM

      zoomInBtn.addEventListener("click", () => {
        if (activeCamera === topCamera) {
          topCamera.fov = Math.max(10, topCamera.fov - 5); // Min FOV = more zoom
          topCamera.updateProjectionMatrix();
        }
      });

      zoomOutBtn.addEventListener("click", () => {
        if (activeCamera === topCamera) {
          topCamera.fov = Math.min(100, topCamera.fov + 5); // Max FOV = less zoom
          topCamera.updateProjectionMatrix();
        }
      });

      //topCamera.position.set(50, 100, 50);
      //topCamera.lookAt(50, 0, 50);

      // Luz ambiente suave
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); // luz geral
      scene.add(ambientLight);

      // Luz direcional clara
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
      directionalLight.position.set(50, 50, 50);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      const container = document.getElementById("container");

      const renderer = new THREE.WebGLRenderer({ antialias: true });

      //Corridor label render
      const labelRenderer = new CSS2DRenderer();

      const stats = new Stats();

      const GRAVITY = 30;
      const STEPS_PER_FRAME = 5;

      const worldOctree = new Octree();

      const playerCollider = new Capsule(
        new THREE.Vector3(50, 0.35, 50),
        new THREE.Vector3(50, 1, 50),
        0.35
      );

      const playerVelocity = new THREE.Vector3();
      const playerDirection = new THREE.Vector3();

      let playerOnFloor = false;
      let mouseTime = 0;

      const keyStates = {};

      const vector1 = new THREE.Vector3();
      const vector2 = new THREE.Vector3();
      const vector3 = new THREE.Vector3();

      let employeeModel;

      let rackGroup = new THREE.Group(); // -> AINDA USADO R
      let corridorGroup = new THREE.Group(); // -> AINDA USADO R
      let bufferGroup = new THREE.Group(); // AINDA USADO
      let spaceGroup = new THREE.Group(); // AINDA USADO
      let dockGroup = new THREE.Group(); // AINDA USADO
      let stackGroup = new THREE.Group(); // AINDA USADO
      let anomalousGroup = new THREE.Group(); // NOVO USADO
      let distribGroup = new THREE.Group(); // NOVO USADO
      let transitionGroup = new THREE.Group(); // NOVO USADO
      let tempDockGroup = new THREE.Group(); // NOVO USADO
      let driveInGroup = new THREE.Group(); //-> NAO USADO

      scene.add(
        rackGroup,
        corridorGroup,
        bufferGroup,
        spaceGroup,
        dockGroup,
        stackGroup,
        driveInGroup,
        anomalousGroup,
        distribGroup,
        transitionGroup,
        tempDockGroup
      );
      console.log("Buffer group tem filhos:", bufferGroup.children.length);
      const baseFloor = new THREE.Mesh(
  new THREE.BoxGeometry(2000, 10, 2000),
  new THREE.MeshBasicMaterial({ visible: false })
);
baseFloor.position.y = -5;
scene.add(baseFloor);
worldOctree.fromGraphNode(baseFloor);

      const tooltip = document.getElementById("tooltip");

      document.addEventListener("keydown", (event) => {
        keyStates[event.code] = true;

        if (event.code === "KeyT") {
          toggleCamera();
        }
      });

      document.addEventListener("keyup", (event) => {
        keyStates[event.code] = false;
      });

      container.addEventListener("mousedown", () => {
        if (
          activeCamera === camera &&
          document.pointerLockElement !== document.body
        ) {
          try {
            document.body.requestPointerLock();
            mouseTime = performance.now();
          } catch (e) {
            console.warn("Pointer lock request failed:", e);
          }
        }
      });

      document.body.addEventListener("mousemove", (event) => {
        if (
          document.pointerLockElement === document.body &&
          activeCamera === camera
        ) {
          mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
          if (document.pointerLockElement === document.body) {
            const sensitivity = 0.002;
            camera.rotation.y -= event.movementX * sensitivity;
            camera.rotation.x -= event.movementY * sensitivity;

            // Limita o olhar vertical (evita loop)
            const maxPitch = Math.PI / 2 - 0.1; // ligeiramente menos que 90°
            const minPitch = -Math.PI / 2 + 0.1; // ligeiramente mais que -90°
            camera.rotation.x = Math.max(
              minPitch,
              Math.min(maxPitch, camera.rotation.x)
            );
          }
        }
      });

      window.addEventListener("resize", onWindowResize);

      // TESTING FUNCTIONS FOR TRANSLATE

      let currentLang = "EN"; // default

    async function translateConfig() {
      try {
        const res = await fetch("/api/lang"); // ← aqui está o endpoint real
        const lang = (await res.text()).trim().toUpperCase(); // ex: "PT"

      if (traduções.Arm[lang]) {
      currentLang = lang;
    } else {
      console.warn("Idioma não suportado:", lang);
    }

    // cria função global t()
    window.t = (key) => {
      const linha = traduções[key];
      return linha?.[currentLang] || linha?.EN || key;
    };

    // // aplica exemplos
    // document.querySelector("#titulo").textContent = t("Arm");
    // document.querySelector("#btnTutorial").textContent = t("Tut");

  } catch (err) {
    console.error("Erro ao obter idioma:", err);
  }
}





      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        topCamera.aspect = window.innerWidth / window.innerHeight;
        topCamera.updateProjectionMatrix();

        orthoCamera.left = (-ORTHO_SIZE * aspect) / 2;
        orthoCamera.right = (ORTHO_SIZE * aspect) / 2;
        orthoCamera.top = ORTHO_SIZE / 2;
        orthoCamera.bottom = -ORTHO_SIZE / 2;
        orthoCamera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }


      // Calculate the bounding box of all the racks and the center
      function calculateWallBoundingBox(racks) {
        const min = new THREE.Vector3(Infinity, Infinity, Infinity);
        const max = new THREE.Vector3(-Infinity, -Infinity, -Infinity);

        racks.forEach((rack) => {
          const position = new THREE.Vector3(
            rack.Spazio_coord_draw_a / 100,
            rack.Spazio_coord_draw_b / 100,
            rack.Spazio_coord_draw_c / 100
          );

          min.min(position);
          max.max(position);
        });

        const center = new THREE.Vector3(
          (min.x + max.x) / 2,
          (min.y + max.y) / 2,
          (min.z + max.z) / 2
        );

        return { min, max, center };
      }

      function createWall(position, size) {
        const geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
        const material = new THREE.MeshLambertMaterial({ color: 0xd1d1d1 });
        const wall = new THREE.Mesh(geometry, material);
        wall.position.copy(position);
        wall.castShadow = true;
        wall.receiveShadow = true;
        scene.add(wall);
        worldOctree.fromGraphNode(wall);
      }
      function createWarehouseAreaFromComponentsAll() {
        const allMeshes = [
          ...classeEspExecMeshes,
          ...classeEspArmMeshes,
          ...classeCaisMeshes,
          ...classeDivEspacosMeshes,
          ...classeZonAnomalasMeshes,
          ...classeEspacoDistrMeshes,
          ...classeTransportesMeshes,
          ...classeTransicaoMeshes,
          ...classePilhaMeshes,
          ...classeCaisTemporarioMeshes,
        ];

        if (allMeshes.length === 0) return;

        // Expande o bounding box com todos os objetos renderizados
        const bounds = new THREE.Box3();
        allMeshes.forEach((mesh) => bounds.expandByObject(mesh));

        const min = bounds.min.clone(); // ponto mínimo (x, y, z)
        const max = bounds.max.clone(); // ponto máximo (x, y, z)

        const wallHeight = 5;
        const wallThickness = 0.05;
        const wallMargin = 10.0; // Margem leve para que tudo caiba dentro com folga

        // Ajusta min/max para incluir margem
        const adjustedMin = min.clone().subScalar(wallMargin);
        const adjustedMax = max.clone().addScalar(wallMargin);

        const width = adjustedMax.x - adjustedMin.x;
        const depth = adjustedMax.z - adjustedMin.z;

        const centerX = (adjustedMin.x + adjustedMax.x) / 2;
        const centerZ = (adjustedMin.z + adjustedMax.z) / 2;

        // Define o centro do armazém para efeitos de teleport ou câmera
        boundingBoxCenter.set(centerX, 0, centerZ);

        // // Cria as 4 paredes
        // createWall(
        //   new THREE.Vector3(centerX, wallHeight / 2, adjustedMin.z),
        //   new THREE.Vector3(width + wallThickness, wallHeight, wallThickness)
        // );
        // createWall(
        //   new THREE.Vector3(centerX, wallHeight / 2, adjustedMax.z),
        //   new THREE.Vector3(width + wallThickness, wallHeight, wallThickness)
        // );
        // createWall(
        //   new THREE.Vector3(adjustedMin.x, wallHeight / 2, centerZ),
        //   new THREE.Vector3(wallThickness, wallHeight, depth + wallThickness)
        // );
        // createWall(
        //   new THREE.Vector3(adjustedMax.x, wallHeight / 2, centerZ),
        //   new THREE.Vector3(wallThickness, wallHeight, depth + wallThickness)
        // );

        // Cria o chão
        const floorGeometry = new THREE.PlaneGeometry(width, depth);
        const floorMaterial = new THREE.MeshLambertMaterial({
          color: 0x30384f,
        });
        // const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        // floor.rotation.x = -Math.PI / 2;
        // floor.position.set(centerX, 0, centerZ);

        // scene.add(floor);
        // worldOctree.fromGraphNode(floor);
        addGridWithFloorBounds(adjustedMin, adjustedMax);
      }

      // F2 change parameter name in all document
      // Create walls around the bounding box with a margin

      // // Update createWalls function to use bounding box
      // function createWalls(wallBoundingBoxCoords) {
      //   if (racks && racks.length > 0) {
      //     createWallsAroundRacks(wallBoundingBoxCoords);
      //   }
      // }

      // Calcula se algum vetor interseta com um bounding box
      function playerCollisions() {
        const result = worldOctree.capsuleIntersect(playerCollider);
        playerOnFloor = false;

        if (result) {
          playerOnFloor = result.normal.y > 0;

          if (!playerOnFloor) {
            playerVelocity.addScaledVector(
              result.normal,
              -result.normal.dot(playerVelocity)
            );
          }

          playerCollider.translate(result.normal.multiplyScalar(result.depth));
        }
      }

      // Atualizar o player a cada frame (colisões, velocidade)
      function updatePlayer(deltaTime) {
        let damping = Math.exp(-4 * deltaTime) - 1;

        if (!playerOnFloor) {
          playerVelocity.y -= GRAVITY * deltaTime;
          damping *= 0.1;
        }

        playerVelocity.addScaledVector(playerVelocity, damping);

        const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
        playerCollider.translate(deltaPosition);

        // colisões
        playerCollisions();

        camera.position.copy(playerCollider.end);
        camera.position.copy(playerCollider.end);

        // Evita que a câmera continue a olhar para baixo após colisões
        if (!document.pointerLockElement) {
          camera.rotation.set(0, 0, 0); // só se não estiver no modo pointerlock
        }

        // Clamp player position inside warehouse bounds
      }

      function getForwardVector() {
        camera.getWorldDirection(playerDirection);
        playerDirection.y = 0;
        playerDirection.normalize();
        return playerDirection;
      }

      function getSideVector() {
        camera.getWorldDirection(playerDirection);
        playerDirection.y = 0;
        playerDirection.normalize();
        playerDirection.cross(camera.up);
        return playerDirection;
      }

      // Ativar movimentos com as teclas
      function handleControls(deltaTime) {
        const speedDelta = deltaTime * (playerOnFloor ? 25 : 8);

        if (activeCamera === camera) {
          if (keyStates["KeyW"]) {
            playerVelocity.add(getForwardVector().multiplyScalar(speedDelta));
          }

          if (keyStates["KeyS"]) {
            playerVelocity.add(getForwardVector().multiplyScalar(-speedDelta));
          }

          if (keyStates["KeyA"]) {
            playerVelocity.add(getSideVector().multiplyScalar(-speedDelta));
          }

          if (keyStates["KeyD"]) {
            playerVelocity.add(getSideVector().multiplyScalar(speedDelta));
          }

          if (playerOnFloor) {
            if (keyStates["Space"]) {
              playerVelocity.y = 15;
            }
          }
        }
      }

      // wtv
      const helper = new OctreeHelper(worldOctree);
      helper.visible = false;
      scene.add(helper);

      // wtv
      // const gui = new GUI({ width: 200 });
      // gui.add({ debug: false }, "debug").onChange(function (value) {
      //   helper.visible = value;
      // });

      // Se o personagem foge do mapa ele volta
      function teleportPlayerIfOob() {
        if (camera.position.y <= -25) {
          playerCollider.start.set(
            boundingBoxCenter.x,
            boundingBoxCenter.y + 0.35,
            boundingBoxCenter.z
          );
          playerCollider.end.set(
            boundingBoxCenter.x,
            boundingBoxCenter.y + 1,
            boundingBoxCenter.z
          );
          playerCollider.radius = 0.35;
          camera.position.copy(playerCollider.end);
          camera.rotation.set(0, Math.PI, 0); // reinicia com rotação para frente
          playerVelocity.set(0, 0, 0); // zera velocidade também
        }
      }

      // Alterar entre camaras
      function toggleCamera() {
        activeCamera = activeCamera === camera ? topCamera : camera;

        if (employeeModel) {
          employeeModel.position.copy(playerCollider.end);
          employeeModel.visible = activeCamera === topCamera;
        }

        if (activeCamera === camera) {
          document.body.requestPointerLock();
        } else {
          document.exitPointerLock();
        }
        orbitControls.target.copy(playerCollider.end);
      }

      const orbitControls = new OrbitControls(topCamera, renderer.domElement);
      //orbitControls.target.set(45, 10, 79.49);
      orbitControls.screenSpacePanning = true;
      orbitControls.minDistance = 1;
      orbitControls.maxDistance = 10000;
      orbitControls.maxPolarAngle = Math.PI / 2;
      orbitControls.enablePan = true;
      orbitControls.enableDamping = true;
      orbitControls.enabled = true;
      orbitControls.dampingFactor = 0.05;

      // Atualização da cena
      function animate() {
        const deltaTime = Math.min(0.05, clock.getDelta()) / STEPS_PER_FRAME;

        for (let i = 0; i < STEPS_PER_FRAME; i++) {
          handleControls(deltaTime);
          updatePlayer(deltaTime);
          teleportPlayerIfOob();
        }

        if (employeeModel) {
          // Toggle visibility of employee based on active camera
          employeeModel.visible = true;
          employeeModel.position.copy(playerCollider.end);
        }
        if (activeCamera === topCamera) {
          moveTopCamera(deltaTime * 60);
          orbitControls.update();
        }

        if (activeCamera === camera) {
          const maxPitch = Math.PI / 2 - 0.1;
          const minPitch = -Math.PI / 2 + 0.1;
          camera.rotation.x = Math.max(
            minPitch,
            Math.min(maxPitch, camera.rotation.x)
          );
        }

    // Código fora da função animate (definido uma vez)
// Definido fora da função animate (no escopo global, uma vez só):
const frustum = new THREE.Frustum();
const cameraViewProjectionMatrix = new THREE.Matrix4();

// Dentro da função animate, substitui a parte antiga por:
activeCamera.updateMatrixWorld(); // garantir matriz atualizada
cameraViewProjectionMatrix.multiplyMatrices(
  activeCamera.projectionMatrix,
  activeCamera.matrixWorldInverse
);
frustum.setFromProjectionMatrix(cameraViewProjectionMatrix);

for (let i = 0; i < outlinesArray.length; i++) {
  const { outline, position } = outlinesArray[i];

  const isHiddenByLayout = outline.userData.hiddenByLayout;
  const isHiddenByHeight2D = outline.userData.hiddenByHeight2D;
  const dist = activeCamera.position.distanceTo(position);
  const isVisibleInFrustum = frustum.containsPoint(position);
  const isNearEnough = dist < 200;

  outline.visible =
    !isHiddenByLayout &&
    !isHiddenByHeight2D &&
    isVisibleInFrustum &&
    isNearEnough;
}



        renderer.render(scene, activeCamera);
        labelRenderer.render(scene, activeCamera);
         
        updateDynamicLabels();

        stats.update();
      }

      // NEW DYNAMIC FUNCTIONS TO DRAW SPACES GM -------------------------------------------------------------------------------------------------------------------------------------

      //Spazio_classe === "01"
      async function createSpacesFromJSON(spacesArray) {
        const spaceOpacity = 0.9;
        const shrinkFactor = 0.65;
        const defaultColor = new THREE.Color("#00ff00");

        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const dummy = new THREE.Object3D();
        const count = spacesArray.length;

        const material = new THREE.MeshBasicMaterial({
          transparent: true,
          opacity: spaceOpacity,
          depthWrite: true,
        });

        const instancedMesh = new THREE.InstancedMesh(
          geometry,
          material,
          count
        );

        const color = new THREE.Color();
        const colorArray = new Float32Array(count * 3); // RGB por instância

        spacesArray.forEach((space, i) => {
          const x = parseFloat(space.Spazio_coord_draw_a || 0) / 100;
          const y = parseFloat(space.Spazio_coord_draw_b || 0) / 100;
          const z = parseFloat(space.Spazio_coord_draw_c || 0) / 100;

          let width = parseFloat(space.Spazio_coord_largo || 80) / 100;
          const height = parseFloat(space.Spazio_coord_alto || 180) / 100;
          let depth = parseFloat(space.Spazio_coord_fondo || 120) / 100;

          const orientation = String(space.Spazio_orientamento || "").trim();
          if (orientation === "1") {
            [width, depth] = [depth, width];
          }

          const px = x + width / 2;
          const py = y + height / 2;
          const pz = z + depth / 2;

          dummy.position.set(px, py, pz);
          dummy.scale.set(
            width * shrinkFactor,
            height * shrinkFactor,
            depth * shrinkFactor
          );
          dummy.updateMatrix();
          instancedMesh.setMatrixAt(i, dummy.matrix);

          let colorString = space.ColoreD;

          try {
            if (colorString && typeof colorString === "string") {
              colorString = colorString.toLowerCase();
              color.set(colorString);
            } else {
              color.copy(defaultColor);
              colorString = "default";
            }
          } catch (err) {
            console.warn(`Cor inválida no espaço[${i}]:`, space.ColoreD);
            color.copy(defaultColor);
            colorString = "default";
          }

          color.toArray(colorArray, i * 3);
        
          //Guardar a escala para a funçao toggleVisibility
          originalScalesByClasse["01"][i] = {
            x: width * shrinkFactor,
            y: height * shrinkFactor,
            z: depth * shrinkFactor,
            tipo: space.Spazio_tipoD
          };
        });

        instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(
          colorArray,
          3
        );

        instancedMesh.instanceMatrix.needsUpdate = true;

        // Associar os dados ao instancedMesh para o toggle funcionar corretamente
        instancedMesh.userData.espacos = [...spacesArray];
        instancedMesh.userData.tipoD =spacesArray[0]?.Spazio_tipoD || "unknown";

        spaceGroup.add(instancedMesh);
        classeEspExecMeshes.push(instancedMesh)
        console.log(
          `Espaços de execucao desenhados (classe 01): ${spacesArray.length}`
        );
      }
      //-------------------------------------------------------------------------------------------------------------------------------------
      //Spazio_classe === "02"
      async function createWarehouseSpacesFromJSON(newBufferItems, isVisible = true) {
        if (!Array.isArray(newBufferItems) || newBufferItems.length === 0) return;

        const bufferOpacity = 0.9;
        const shrinkFactor = 0.65;
        const defaultColor = new THREE.Color("#d48c8c");
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const dummy = new THREE.Object3D();

        const material = new THREE.MeshBasicMaterial({
          color: defaultColor,
          transparent: true,
          opacity: bufferOpacity,
          depthWrite: true,
        });

        const tipo = newBufferItems[0].Spazio_tipo;
        const classe = "02";

        const existingMesh = bufferGroup.children.find(
          (child) => child.isInstancedMesh && child.userData?.classe === classe
        );

        // Se já existir o tipo, atualiza escalas apenas
        if (existingMesh && existingMesh.userData.espacos?.some(e => e.Spazio_tipo === tipo)) {
          const tempMatrix = new THREE.Matrix4();
          const espacos = existingMesh.userData.espacos;
          const scales = originalScalesByClasse[classe] || {};

          espacos.forEach((item, i) => {
            if (item.Spazio_tipo === tipo) {
              existingMesh.getMatrixAt(i, tempMatrix);
              tempMatrix.decompose(dummy.position, dummy.quaternion, dummy.scale);

              const original = scales[i];
              const targetScale = isVisible
                ? original || dummy.scale
                : { x: 0.0001, y: 0.0001, z: 0.0001 };

              dummy.scale.set(targetScale.x, targetScale.y, targetScale.z);
              dummy.updateMatrix();
              existingMesh.setMatrixAt(i, dummy.matrix);
            }
          });

          existingMesh.instanceMatrix.needsUpdate = true;

          return;
        }

        // Caso contrário, adicionar os novos itens
        const existingCount = existingMesh?.count || 0;
        const newCount = newBufferItems.length;
        const totalCount = existingCount + newCount;

        const mergedMesh = new THREE.InstancedMesh(geometry, material, totalCount);
        const color = new THREE.Color();
        const colorArray = new Float32Array(totalCount * 3);
        const tempMatrix = new THREE.Matrix4();

        const mergedEspacos = existingMesh?.userData.espacos
          ? [...existingMesh.userData.espacos]
          : [];

        // Copia instâncias existentes
        if (existingMesh) {
          for (let i = 0; i < existingCount; i++) {
            existingMesh.getMatrixAt(i, tempMatrix);
            mergedMesh.setMatrixAt(i, tempMatrix);
          }

          const oldColors = existingMesh.instanceColor?.array || [];
          colorArray.set(oldColors);

          bufferGroup.remove(existingMesh);
          const idx = classeEspArmMeshes.indexOf(existingMesh);
          if (idx !== -1) classeEspArmMeshes.splice(idx, 1);
        }

        // Inicializa estrutura de escalas
        if (!originalScalesByClasse[classe]) originalScalesByClasse[classe] = {};

        // Adiciona os novos
        newBufferItems.forEach((item, i) => {
          const index = existingCount + i;

          const x = parseFloat(item.Spazio_coord_draw_a || 0) / 100;
          const y = parseFloat(item.Spazio_coord_draw_b || 0) / 100;
          const z = parseFloat(item.Spazio_coord_draw_c || 0) / 100;

          let width = parseFloat(item.Spazio_coord_largo || 80) / 100;
          const height = parseFloat(item.Spazio_coord_alto || 180) / 100;
          let depth = parseFloat(item.Spazio_coord_fondo || 120) / 100;

          if (String(item.Spazio_orientamento || "").trim() === "1") {
            [width, depth] = [depth, width];
          }

          const scale = {
            x: width * shrinkFactor,
            y: height * shrinkFactor,
            z: depth * shrinkFactor,
          };

          dummy.position.set(x + width / 2, y + height / 2, z + depth / 2);
          dummy.scale.set(scale.x, scale.y, scale.z);
          dummy.updateMatrix();
          mergedMesh.setMatrixAt(index, dummy.matrix);

          try {
            color.set((item.ColoreD || "").toLowerCase());
          } catch {
            color.copy(defaultColor);
          }

          color.toArray(colorArray, index * 3);

          originalScalesByClasse[classe][index] = { ...scale, tipo: item.Spazio_tipoD };
          mergedEspacos.push(item);
        });

        mergedMesh.instanceColor = new THREE.InstancedBufferAttribute(colorArray, 3);
        mergedMesh.instanceMatrix.needsUpdate = true;
        mergedMesh.userData.espacos = mergedEspacos;
        mergedMesh.userData.tipo = tipo;
        mergedMesh.userData.classe = classe;

        bufferGroup.add(mergedMesh);
        classeEspArmMeshes.push(mergedMesh);

      }

      //-------------------------------------------------------------------------------------------------------------------------------------
      //Spazio_classe === "03" // SEM OPÇAO DE METER ALTURA AINDA
      async function createDockFromJSON(docks) {
        const shrinkFactor = 1;
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const dummy = new THREE.Object3D();
        dockGroup.clear();
        const outlineGroup = new THREE.Group();
        const defaultColor = new THREE.Color("#0080ff"); // azul suave para docks

        const count = docks.length;

        const material = new THREE.MeshBasicMaterial({
          color: defaultColor,
          transparent: true,
          opacity: 0.9,
          depthWrite: true,
        });

        const instancedMesh = new THREE.InstancedMesh(geometry, material, count);
        instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

        const outlineGeometry = new THREE.EdgesGeometry(geometry);
        const outlineMaterial = new THREE.LineBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 1,
        });

        const color = new THREE.Color();
        const colorArray = new Float32Array(count * 3);

        docks.forEach((dock, i) => {
          // ⬇️ Forçar altura e Spazio_coord_alto para consistência com labels
          let width = parseFloat(dock.Spazio_coord_largo || 100) / 100;
          let height = 0.01;
          let depth = parseFloat(dock.Spazio_coord_fondo || 100) / 100;

          const x = parseFloat(dock.Spazio_coord_draw_a || 0) / 100;
          const y = parseFloat(dock.Spazio_coord_draw_b || 0) / 100;
          const z = parseFloat(dock.Spazio_coord_draw_c || 0) / 100;

          const orientation = String(dock.Spazio_orientamento || "").trim();
          if (orientation === "1") {
            [width, depth] = [depth, width];
          }

          dummy.position.set(x + width / 2, y + height / 2, z + depth / 2);
                dummy.scale.set(width * shrinkFactor, 0.05, depth * shrinkFactor); // 0.05 de altura "quase plano"
          dummy.updateMatrix();
          instancedMesh.setMatrixAt(i, dummy.matrix);


          // ⬇️ Preserva userData para relacionamento
          instancedMesh.userData.tipo = dock.Spazio_tipo;
          instancedMesh.userData.tipoD = dock.Spazio_tipoD;
          instancedMesh.userData.spazio_disp = dock.Spazio_disponibile;

          const outline = new THREE.LineSegments(outlineGeometry, outlineMaterial.clone());
          outline.applyMatrix4(dummy.matrix);
          outline.visible = false;
          outline.userData.tipoD = dock.Spazio_tipoD;
          outlineGroup.add(outline);

          outlinesArray.push({
            outline,
            position: dummy.position.clone(),
          });

          let colorString = dock.ColoreD;
          try {
            if (colorString && typeof colorString === "string") {
              color.set(colorString.toLowerCase());
            } else {
              color.copy(defaultColor);
            }
          } catch {
            color.copy(defaultColor);
          }

          color.toArray(colorArray, i * 3);

          // Guarda escala original
          originalScalesByClasse["03"][i] = {
            x: width * shrinkFactor,
            y: height,
            z: depth * shrinkFactor,
            tipo: dock.Spazio_tipoD
          };
        });

        instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(colorArray, 3);
        instancedMesh.instanceMatrix.needsUpdate = true;

        // Salva todos os docks no userData
        instancedMesh.userData.espacos = [...docks];
        instancedMesh.userData.tipoD = docks[0]?.Spazio_tipoD || "unknown";

        dockGroup.add(instancedMesh);
        outlineGroup.children.forEach((child) => dockGroup.add(child));
        classeCaisMeshes.push(instancedMesh);
        scene.add(dockGroup);

        console.log(`Espaços de cais desenhados (classe 03): ${docks.length}`);
      }

      //-------------------------------------------------------------------------------------------------------------------------------------
      //Spazio_classe === "05" Zonas Anómalas

      async function createAnomalousZonesFromJSON(zonas) {
        const shrinkFactor = 1;
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const dummy = new THREE.Object3D();
        anomalousGroup.clear();
        const outlineGroup = new THREE.Group();
        const defaultColor = new THREE.Color("#ff4d4d"); // vermelho claro de alerta

        const count = zonas.length;

        const material = new THREE.MeshBasicMaterial({
          color: defaultColor,
          transparent: true,
          opacity: 0.85,
          depthWrite: true,
        });

        const instancedMesh = new THREE.InstancedMesh(
          geometry,
          material,
          count
        );
        instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

        const outlineGeometry = new THREE.EdgesGeometry(geometry);
        const outlineMaterial = new THREE.LineBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 1,
        });

        const color = new THREE.Color();
        const colorArray = new Float32Array(count * 3);

        zonas.forEach((item, i) => {
          let width = parseFloat(item.Spazio_coord_largo || 100) / 100;
          let depth = parseFloat(item.Spazio_coord_fondo || 100) / 100;

          const x = parseFloat(item.Spazio_coord_draw_a || 0) / 100;
          const y = parseFloat(item.Spazio_coord_draw_b || 0) / 100;
          const z = parseFloat(item.Spazio_coord_draw_c || 0) / 100;

          const orientation = String(item.Spazio_orientamento || "").trim();
          if (orientation === "1") {
            [width, depth] = [depth, width];
          }

          dummy.position.set(x + width / 2, y, z + depth / 2);
          dummy.scale.set(width * shrinkFactor, 0.05, depth * shrinkFactor); // 0.05 de altura "quase plano"
          dummy.updateMatrix();
          instancedMesh.setMatrixAt(i, dummy.matrix);
          instancedMesh.userData.tipo = item.Spazio_tipo;
          instancedMesh.userData.tipoD = item.Spazio_tipoD;
          instancedMesh.userData.spazio_disp = item.Spazio_disponibile;
          // Contorno
          const outline = new THREE.LineSegments(
            outlineGeometry,
            outlineMaterial.clone()
          );
          outline.applyMatrix4(dummy.matrix);
          outline.visible = false;
          outline.userData.tipoD = item.Spazio_tipoD;
          outlineGroup.add(outline);

          outlinesArray.push({
            outline,
            position: dummy.position.clone(),
          });

          let colorString = item.ColoreD;
          try {
            if (colorString && typeof colorString === "string") {
              colorString = colorString.toLowerCase();
              color.set(colorString);
            } else {
              color.copy(defaultColor);
            }
          } catch (err) {
            console.warn(`Cor inválida na zona anómala [${i}]:`, item.ColoreD);
            color.copy(defaultColor);
          }

          color.toArray(colorArray, i * 3);

          //Guardar a escala para a funçao toggleVisibility
          originalScalesByClasse["05"][i] = {
            x: width * shrinkFactor,
            y: 0.05,
            z: depth * shrinkFactor,
            tipo: item.Spazio_tipoD
          };
        });

        instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(
          colorArray,
          3
        );
        instancedMesh.instanceMatrix.needsUpdate = true;

        instancedMesh.userData.espacos = [...zonas];
        instancedMesh.userData.tipoD = zonas[0]?.Spazio_tipoD || "unknown";

        anomalousGroup.add(instancedMesh);
        outlineGroup.children.forEach((child) => {
          anomalousGroup.add(child);
        });
        scene.add(anomalousGroup);
        classeZonAnomalasMeshes.push(instancedMesh);

        console.log(`Zonas Anómalas desenhadas (classe 05): ${zonas.length}`);
      }

      //-------------------------------------------------------------------------------------------------------------------------------------
      // Spazio_classe === "06" ZONAS DE DISTRIBUIÇAO

async function createDistributionFromJSON(distribuicoes) {
  const shrinkFactor = 1;
  const geometry = new THREE.BoxGeometry(1, 1, 1);
  distribGroup.clear();
  const defaultColor = new THREE.Color("#ffc107");

  const count = distribuicoes.length;
  const material = new THREE.MeshBasicMaterial({
    color: defaultColor,
    transparent: true,
    opacity: 0.9,
  });

  const instancedMesh = new THREE.InstancedMesh(geometry, material, count);
  const dummy = new THREE.Object3D();

  const outlineMaterial = new THREE.LineBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 1,
  });

  const color = new THREE.Color();
  const colorArray = new Float32Array(count * 3); // RGB por instância

 

  distribuicoes.forEach((item, i) => {
    const width = parseFloat(item.Spazio_coord_largo || 100) / 100;
    const height = parseFloat(item.Spazio_coord_alto || 100) / 100;
    const depth = parseFloat(item.Spazio_coord_fondo || 100) / 100;

    const x = parseFloat(item.Spazio_coord_draw_a || 0) / 100;
    const y = parseFloat(item.Spazio_coord_draw_b || 0) / 100;
    const z = parseFloat(item.Spazio_coord_draw_c || 0) / 100;

    // InstancedMesh
    dummy.position.set(x + width / 2, y + height / 2, z + depth / 2);
    dummy.scale.set(
      width * shrinkFactor,
      height * shrinkFactor,
      depth * shrinkFactor
    );
    dummy.updateMatrix();
    instancedMesh.setMatrixAt(i, dummy.matrix);

    instancedMesh.userData.tipo = item.Spazio_tipo;
    instancedMesh.userData.tipoD = item.Spazio_tipoD;
    instancedMesh.userData.spazio_disp = item.Spazio_disponibile;

    // Cor
    let colorString = item.ColoreD;
    try {
      if (colorString && typeof colorString === "string") {
        colorString = colorString.toLowerCase();
        color.set(colorString);
      } else {
        color.copy(defaultColor);
      }
    } catch (err) {
      console.warn(`Cor inválida no espaço[${i}]:`, item.ColoreD);
      color.copy(defaultColor);
    }
    color.toArray(colorArray, i * 3);

    // Contorno individual correto (sem dummy)
    const boxGeo = new THREE.BoxGeometry(
      width * shrinkFactor,
      height * shrinkFactor,
      depth * shrinkFactor
    );
    const edgeGeo = new THREE.EdgesGeometry(boxGeo);
    const outline = new THREE.LineSegments(edgeGeo, outlineMaterial.clone());
    outline.position.set(x + width / 2, y + height / 2, z + depth / 2);
    outline.visible = false;
    outline.userData.tipoD = item.Spazio_tipoD;

    distribGroup.add(outline); // junta diretamente ao grupo de distribuição

    outlinesArray.push({
      outline,
      position: outline.position.clone(),
    });

    // Escala original
    originalScalesByClasse["06"][i] = {
      x: width * shrinkFactor,
      y: height * shrinkFactor,
      z: depth * shrinkFactor,
      tipo: item.Spazio_tipoD
    };
  });

  instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(
    colorArray,
    3
  );
  instancedMesh.instanceMatrix.needsUpdate = true;

  instancedMesh.userData.espacos = [...distribuicoes];
  instancedMesh.userData.tipoD = distribuicoes[0]?.Spazio_tipoD || "unknown";

  distribGroup.add(instancedMesh);
  classeEspacoDistrMeshes.push(instancedMesh);

  scene.add(distribGroup);

  console.log(
    `Estações de loja desenhadas (classe 06): ${distribuicoes.length}`
  );
}


      //-------------------------------------------------------------------------------------------------------------------------------------
      //Spazio_classe === "08" Transition Zones

      async function createTransitionZonesFromJSON(transitionZones) {
        const shrinkFactor = 1;
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const dummy = new THREE.Object3D();
        transitionGroup.clear();
        const outlineGroup = new THREE.Group();
        const defaultColor = new THREE.Color("#80d8ff"); // azul claro

        const count = transitionZones.length;

        const material = new THREE.MeshBasicMaterial({
          color: defaultColor,
          transparent: true,
          opacity: 0.9,
          depthWrite: true,
        });

        const instancedMesh = new THREE.InstancedMesh(
          geometry,
          material,
          count
        );
        instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

        const outlineGeometry = new THREE.EdgesGeometry(geometry);
        const outlineMaterial = new THREE.LineBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 1,
        });

        const color = new THREE.Color();
        const colorArray = new Float32Array(count * 3);

        transitionZones.forEach((item, i) => {
          let width = parseFloat(item.Spazio_coord_largo || 100) / 100;
          const height = parseFloat(item.Spazio_coord_alto || 100) / 100;
          let depth = parseFloat(item.Spazio_coord_fondo || 100) / 100;

          const x = parseFloat(item.Spazio_coord_draw_a || 0) / 100;
          const y = parseFloat(item.Spazio_coord_draw_b || 0) / 100;
          const z = parseFloat(item.Spazio_coord_draw_c || 0) / 100;

          const orientation = String(item.Spazio_orientamento || "").trim();
          if (orientation === "1") [width, depth] = [depth, width];

          dummy.position.set(x + width / 2, y + height / 2, z + depth / 2);
          dummy.scale.set(
            width * shrinkFactor,
            height * shrinkFactor,
            depth * shrinkFactor
          );
          dummy.updateMatrix();
          instancedMesh.setMatrixAt(i, dummy.matrix);
          instancedMesh.userData.tipo = item.Spazio_tipo;
          instancedMesh.userData.tipoD = item.Spazio_tipoD;
          instancedMesh.userData.spazio_disp = item.Spazio_disponibile;
          const outline = new THREE.LineSegments(
            outlineGeometry,
            outlineMaterial.clone()
          );
          outline.applyMatrix4(dummy.matrix);
          outline.visible = false;
          outline.userData.tipoD = item.Spazio_tipoD;
          outlineGroup.add(outline);

          outlinesArray.push({
            outline,
            position: dummy.position.clone(),
          });

          let colorString = item.ColoreD;
          try {
            if (colorString && typeof colorString === "string") {
              color.set(colorString.toLowerCase());
            } else {
              color.copy(defaultColor);
            }
          } catch (err) {
            console.warn(`Cor inválida no espaço[${i}]:`, item.ColoreD);
            color.copy(defaultColor);
          }

          color.toArray(colorArray, i * 3);

          //Guardar a escala para a funçao toggleVisibility
          originalScalesByClasse["08"][i] = {
            x: width * shrinkFactor,
            y: height * shrinkFactor,
            z: depth * shrinkFactor,
            tipo: item.Spazio_tipoD
          };
        });

        instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(
          colorArray,
          3
        );
        instancedMesh.instanceMatrix.needsUpdate = true;

        instancedMesh.userData.espacos = [...transitionZones];
        instancedMesh.userData.tipoD =
          transitionZones[0]?.Spazio_tipoD || "unknown";

        transitionGroup.add(instancedMesh);
        outlineGroup.children.forEach((child) => {
          transitionGroup.add(child);
        });
        scene.add(transitionGroup);
        classeTransicaoMeshes.push(instancedMesh);

        console.log(`Zonas de Transição desenhadas (classe 08): ${count}`);
      }

      //-------------------------------------------------------------------------------------------------------------------------------------
      //Spazio_classe === "09"
      async function createStacksFromJSON(stacksArray) {
  const shrinkFactor = 1;
  const geometry = new THREE.BoxGeometry(1, 1, 1);
  stackGroup.clear();
  const defaultColor = new THREE.Color("#9966ff");
  const count = stacksArray.length;

  const material = new THREE.MeshBasicMaterial({
    color: defaultColor,
    transparent: true,
    opacity: 0.9,
    depthWrite: true,
  });

  const instancedMesh = new THREE.InstancedMesh(geometry, material, count);
  const dummy = new THREE.Object3D();

  const outlineMaterial = new THREE.LineBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 1,
  });

  const color = new THREE.Color();
  const colorArray = new Float32Array(count * 3);


  stacksArray.forEach((item, i) => {
    let width = parseFloat(item.Spazio_coord_largo || 100) / 100;
    let depth = parseFloat(item.Spazio_coord_fondo || 100) / 100;
    const height = parseFloat(item.Spazio_coord_alto || 100) / 100;

    const x = parseFloat(item.Spazio_coord_draw_a || 0) / 100;
    const y = parseFloat(item.Spazio_coord_draw_b || 0) / 100;
    const z = parseFloat(item.Spazio_coord_draw_c || 0) / 100;

    const orientation = String(item.Spazio_orientamento || "").trim();
    if (orientation === "1") {
      [width, depth] = [depth, width];
    }

    dummy.position.set(x + width / 2, y + height / 2, z + depth / 2);
    dummy.scale.set(
      width * shrinkFactor,
      height * shrinkFactor,
      depth * shrinkFactor
    );
    dummy.updateMatrix();
    instancedMesh.setMatrixAt(i, dummy.matrix);

    instancedMesh.userData.tipo = item.Spazio_tipo;
    instancedMesh.userData.tipoD = item.Spazio_tipoD;
    instancedMesh.userData.spazio_disp = item.Spazio_disponibile;

    // Cor
    let colorString = item.ColoreD;
    try {
      if (colorString && typeof colorString === "string") {
        color.set(colorString.toLowerCase());
      } else {
        color.copy(defaultColor);
      }
    } catch (err) {
      console.warn(`Cor inválida no espaço[${i}]:`, item.ColoreD);
      color.copy(defaultColor);
    }
    color.toArray(colorArray, i * 3);

    // Contorno individual correto
    const boxGeo = new THREE.BoxGeometry(
      width * shrinkFactor,
      height * shrinkFactor,
      depth * shrinkFactor
    );
    const edgeGeo = new THREE.EdgesGeometry(boxGeo);
    const outline = new THREE.LineSegments(edgeGeo, outlineMaterial.clone());
    outline.position.set(x + width / 2, y + height / 2, z + depth / 2);
    outline.visible = false;
    outline.userData.tipoD = item.Spazio_tipoD;

    stackGroup.add(outline);

    outlinesArray.push({
      outline,
      position: outline.position.clone(),
    });

    // Escala original
    originalScalesByClasse["09"][i] = {
      x: width * shrinkFactor,
      y: height * shrinkFactor,
      z: depth * shrinkFactor,
      tipo: item.Spazio_tipoD
    };
  });

  instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(colorArray, 3);
  instancedMesh.instanceMatrix.needsUpdate = true;

  instancedMesh.userData.espacos = [...stacksArray];
  instancedMesh.userData.tipoD = stacksArray[0]?.Spazio_tipoD || "unknown";

  stackGroup.add(instancedMesh);
  classePilhaMeshes.push(instancedMesh);
  scene.add(stackGroup);

  console.log(`Pilhas desenhadas (classe 09): ${count}`);
}

      //-------------------------------------------------------------------------------------------------------------------------------------
      //Spazio_classe === "10" Cais Temporario ainda sem a funcionalidade da altura

      async function createTemporaryDockFromJSON(tempDocks) {
  const shrinkFactor = 1;
  const geometry = new THREE.BoxGeometry(1, 1, 1);
  tempDockGroup.clear();
  const defaultColor = new THREE.Color("#ffb74d");
  const count = tempDocks.length;

  const material = new THREE.MeshBasicMaterial({
    color: defaultColor,
    transparent: true,
    opacity: 0.9,
    depthWrite: true,
  });

  const instancedMesh = new THREE.InstancedMesh(geometry, material, count);
  const dummy = new THREE.Object3D();

  const outlineMaterial = new THREE.LineBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 1,
  });

  const color = new THREE.Color();
  const colorArray = new Float32Array(count * 3);


  tempDocks.forEach((item, i) => {
    let width = parseFloat(item.Spazio_coord_largo || 100) / 100;
    let depth = parseFloat(item.Spazio_coord_fondo || 100) / 100;
    const height = 0.1;

    const x = parseFloat(item.Spazio_coord_draw_a || 0) / 100;
    const y = parseFloat(item.Spazio_coord_draw_b || 0) / 100;
    const z = parseFloat(item.Spazio_coord_draw_c || 0) / 100;

    const orientation = String(item.Spazio_orientamento || "").trim();
    if (orientation === "1") [width, depth] = [depth, width];

    dummy.position.set(x + width / 2, y + height / 2, z + depth / 2);
    dummy.scale.set(
      width * shrinkFactor,
      height * shrinkFactor,
      depth * shrinkFactor
    );
    dummy.updateMatrix();
    instancedMesh.setMatrixAt(i, dummy.matrix);

    instancedMesh.userData.tipo = item.Spazio_tipo;
    instancedMesh.userData.tipoD = item.Spazio_tipoD;
    instancedMesh.userData.spazio_disp = item.Spazio_disponibile;

    // Cor
    let colorString = item.ColoreD;
    try {
      if (colorString && typeof colorString === "string") {
        color.set(colorString.toLowerCase());
      } else {
        color.copy(defaultColor);
      }
    } catch (err) {
      console.warn(`Cor inválida no espaço[${i}]:`, item.ColoreD);
      color.copy(defaultColor);
    }
    color.toArray(colorArray, i * 3);

    // Contorno correto por item (sem dummy)
    const boxGeo = new THREE.BoxGeometry(
      width * shrinkFactor,
      height * shrinkFactor,
      depth * shrinkFactor
    );
    const edgeGeo = new THREE.EdgesGeometry(boxGeo);
    const outline = new THREE.LineSegments(edgeGeo, outlineMaterial.clone());
    outline.position.set(x + width / 2, y + height / 2, z + depth / 2);
    outline.visible = false;
    outline.userData.tipoD = item.Spazio_tipoD;

    tempDockGroup.add(outline);
    outlinesArray.push({
      outline,
      position: outline.position.clone(),
    });

    // Escalas para toggleVisibility
    originalScalesByClasse["10"][i] = {
      x: width * shrinkFactor,
      y: height * shrinkFactor,
      z: depth * shrinkFactor,
      tipo: item.Spazio_tipoD,
      
    };
  });

  instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(colorArray, 3);
  instancedMesh.instanceMatrix.needsUpdate = true;

  instancedMesh.userData.espacos = [...tempDocks];
  instancedMesh.userData.tipoD = tempDocks[0]?.Spazio_tipoD || "unknown";

  tempDockGroup.add(instancedMesh);
  classeCaisTemporarioMeshes.push(instancedMesh);
  scene.add(tempDockGroup);

  console.log(`Cais Temporários desenhados (classe 10): ${count}`);
}



async function toggleWarehouse() {
  const allTipoDLabels = Object.keys(EspacosPorTipoD);

  for (const tipoD of allTipoDLabels) {
    await toggleLayoutVisibility(tipoD, !isWarehouseVisible);
  }

  isWarehouseVisible = !isWarehouseVisible;

  createSelectsLevels()

}

      // END NEW DYNAMIC FUNCTIONS TO DRAW SPACES
 async function createRacksFromJSON(racks) {
  const shrinkFactor = 0.95;
  const geometry = new THREE.BoxGeometry(1, 1, 1);
  const dummy = new THREE.Object3D();
  const count = racks.length;
  const defaultColor = new THREE.Color(0x000000);

  const material = new THREE.MeshBasicMaterial({
    color: defaultColor,
    transparent: true,
    opacity: 0,
    depthWrite: false,
  });

  const instancedMesh = new THREE.InstancedMesh(geometry, material, count);
  instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

  const outlineMaterial = new THREE.LineBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 1,
  });

  const colorArray = new Float32Array(count * 3);
  const outlineGroup = new THREE.Group();

  racks.forEach((rack, i) => {
    const x = parseFloat(rack.Spazio_coord_draw_a || 0) / 100;
    const y = parseFloat(rack.Spazio_coord_draw_b || 0) / 100;
    const z = parseFloat(rack.Spazio_coord_draw_c || 0) / 100;

    let width = parseFloat(rack.Spazio_coord_largo || 120) / 100;
    let height = parseFloat(rack.Spazio_coord_alto || 925) / 100;
    let depth = parseFloat(rack.Spazio_coord_fondo || 320) / 100;

    const orientation = String(rack.Spazio_orientamento || "").trim();
    if (orientation === "2") {
      [width, depth] = [depth, width];
    }

    const posX = x + width / 2;
    const posY = y + height / 2;
    const posZ = z + depth / 2;

    // Instanced mesh
    dummy.position.set(posX, posY, posZ);
    dummy.scale.set(width * shrinkFactor, height * shrinkFactor, depth * shrinkFactor);
    dummy.updateMatrix();
    instancedMesh.setMatrixAt(i, dummy.matrix);

    defaultColor.toArray(colorArray, i * 3);

    // Outline individual
    const boxGeo = new THREE.BoxGeometry(width * shrinkFactor, height * shrinkFactor, depth * shrinkFactor);
    const edgeGeo = new THREE.EdgesGeometry(boxGeo);
    const outline = new THREE.LineSegments(edgeGeo, outlineMaterial.clone());
    outline.position.set(posX, posY, posZ);
    outline.visible = false;
    outline.frustumCulled = false;
    outline.userData.tipo = rack.Spazio_tipo;
    outline.userData.tipoD = rack.Spazio_tipoD;
    outline.userData.spazio_disp = rack.Spazio_disponibile;

    outlineGroup.add(outline);
    outlinesArray.push({
      outline,
      position: outline.position.clone(),
    });

 
  });

  instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(colorArray, 3);
  instancedMesh.instanceMatrix.needsUpdate = true;

  instancedMesh.userData.espacos = [...racks];
  instancedMesh.userData.tipoD = racks[0]?.Spazio_tipoD;
  instancedMesh.userData.tipo = racks[0]?.Spazio_tipo;

  outlineGroup.userData.tipo = racks[0].Spazio_tipo;
  outlineGroup.userData.tipoD = racks[0].Spazio_tipoD;
  outlineGroup.userData.spazio_disp = racks[0].Spazio_disponibile;

  rackGroup.add(instancedMesh);
  rackGroup.add(outlineGroup);
  // outlineGroup.children.forEach((child) => rackGroup.add(child));
  classeDivEspacosMeshes.push(instancedMesh);

  console.log(`Racks desenhados (classe 01): ${count}`);
}

      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      let hoveredRack = null;

      function isFullyVisible(obj) {
        if (!obj.visible) return false;
        let parent = obj.parent;
        while (parent) {
          if (!parent.visible) return false;
          parent = parent.parent;
        }
        return true;
      }
 function onMouseMove(event) {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, activeCamera);

  const instancedTargets = [
    ...classeEspExecMeshes.filter((m) => m.isInstancedMesh),
    ...classeDivEspacosMeshes.filter((m) => m.isInstancedMesh),
    ...classeEspArmMeshes.filter((m) => m.isInstancedMesh),
    ...classeCaisMeshes.filter((m) => m.isInstancedMesh),
    ...classeZonAnomalasMeshes.filter((m) => m.isInstancedMesh),
    ...classeEspacoDistrMeshes.filter((m) => m.isInstancedMesh),
    ...classeTransportesMeshes.filter((m) => m.isInstancedMesh),
    ...classeTransicaoMeshes.filter((m) => m.isInstancedMesh),
    ...classePilhaMeshes.filter((m) => m.isInstancedMesh),
    ...classeCaisTemporarioMeshes.filter((m) => m.isInstancedMesh),
  ];

  const intersects = raycaster.intersectObjects(instancedTargets, true);

  if (intersects.length > 0) {
    const intersect = intersects[0];
    const mesh = intersect.object;
    const instanceId = intersect.instanceId;

    if (mesh && mesh.isInstancedMesh && typeof instanceId === "number") {
      if (
        hoveredInstance &&
        (hoveredInstance.mesh !== mesh || hoveredInstance.id !== instanceId)
      ) {
        hoveredInstance = null;
      }

      if (!hoveredInstance) {
        hoveredInstance = { mesh, id: instanceId };
      }

      const pos = intersect.point;

      const espacos = mesh.userData.espacos || [];
      const espaco = espacos[instanceId];

      let disponibilidade = "Desconhecido";
      if (espaco && espaco.Spazio_disponibile === "0") {
        disponibilidade = "Espaço Indisponível";
      } else if (espaco) {
        disponibilidade = "Espaço Disponível";
      }

      tooltip.style.left = event.clientX + 10 + "px";
      tooltip.style.top = event.clientY + 10 + "px";
      tooltip.innerHTML = `
        <strong>${espaco?.Spazio_tipoD || mesh.userData.tipoD || "Tipo"}</strong><br>
        ID: ${espaco?.Spazio || instanceId}<br>
        ${disponibilidade}
      `;
      tooltip.style.display = "block";
      document.body.style.cursor = "pointer";
      return;
    }
  }

  if (hoveredInstance) {
    hoveredInstance = null;
  }

  tooltip.style.display = "none";
  document.body.style.cursor = "default";
}

      window.addEventListener("mousemove", onMouseMove);

      const topCamMoveSpeed = 5;

      function moveTopCamera(deltaTime) {
        const speed = topCamMoveSpeed * deltaTime;

        const forward = new THREE.Vector3();
        topCamera.getWorldDirection(forward);
        forward.y = 0;
        forward.normalize();

        const right = new THREE.Vector3();
        right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

        const move = new THREE.Vector3();

        if (keyStates["KeyW"]) move.add(forward); // Forward
        if (keyStates["KeyS"]) move.sub(forward); // Backward
        if (keyStates["KeyD"]) move.add(right); // Right
        if (keyStates["KeyA"]) move.sub(right); // Left

        move.normalize().multiplyScalar(speed);
        topCamera.position.add(move);
        // After moving camera

        employeeModel.position.copy(topCamera.position);

        orbitControls.target.add(move);
      }
      // cria um cubo que representa a posição do empregado
      function createEmployee() {
        const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.6); // Adjust size as needed
        const material = new THREE.MeshLambertMaterial({ color: 0xff0000 }); // Adjust color and material as needed
        employeeModel = new THREE.Mesh(geometry, material);
        employeeModel.position.copy(playerCollider.end); // Position the cube where the employee model would be
        employeeModel.visible = false; // Initially hide the cube
        scene.add(employeeModel);
      }

      const tiposAtivos = new Set();
const labelsAtivas = new Map(); // key: Spazio, value: { labelObj, tipo }


 function addLabelForSingleComponent(component, type = "") {
  if (!component || !component.Spazio) return null;

  const label = component.Spazio;

  const x = parseFloat(component.Spazio_coord_draw_a || 0) / 100;
  const y = parseFloat(component.Spazio_coord_draw_b || 0) / 100;
  const z = parseFloat(component.Spazio_coord_draw_c || 0) / 100;

  const width = parseFloat(component.Spazio_coord_largo || 0) / 100;
  const height = parseFloat(component.Spazio_coord_alto || 0) / 100;
  const depth = parseFloat(component.Spazio_coord_fondo || 0) / 100;

  const labelDiv = document.createElement("div");
  labelDiv.className = `label toggle-label toggle-label-${type}`;
  labelDiv.textContent = label;
  labelDiv.style.cssText = `
    color: white;
    font-size: 12px;
    font-weight: bold;
    pointer-events: none;
    background-color: transparent;
    padding: 2px 4px;
    border-radius: 4px;
    z-index: -1;
  `;

  const labelObj = new CSS2DObject(labelDiv);
  labelDiv.__threeObj = labelObj;
  labelObj.position.set(0, 0.05, 0);
  labelObj.rotation.x = -Math.PI / 2;

  const dummy = new THREE.Object3D();
  if (component.Spazio_coord_alto === "0.001") {
    dummy.position.set(x + width / 2, 0, z + depth / 2);
  } else {
    dummy.position.set(x + width / 2, y+height, z + depth / 2);
  }

  dummy.add(labelObj);
  scene.add(dummy);

  return labelObj;
}

 const _vector = new THREE.Vector3();
const _cameraMatrixInverse = new THREE.Matrix4();
const _cameraVPMatrix = new THREE.Matrix4();
const _frustum = new THREE.Frustum();

let racksSet = new Set();
let corridorSet = new Set();

function cacheSpazioSets() {
  racksSet.clear();
  corridorSet.clear();

  rackGroup.children.forEach(child => {
    child.userData?.espacos?.forEach(e => racksSet.add(e.Spazio));
  });

  corridorGroup.children.forEach(child => {
    child.userData?.espacos?.forEach(e => corridorSet.add(e.Spazio));
  });
}

function updateDynamicLabels() {
  topCamera.updateMatrixWorld();
  _cameraMatrixInverse.copy(topCamera.matrixWorld).invert();
  _cameraVPMatrix.multiplyMatrices(topCamera.projectionMatrix, _cameraMatrixInverse);
  _frustum.setFromProjectionMatrix(_cameraVPMatrix);

  const tipoValorMap = new Map();
  tiposValores.forEach(({ tipo, valor }) => {
    tipoValorMap.set(tipo, parseInt(valor) || 0);
  });

  for (const item of EspacosAll) {
    const spazioId = item.Spazio;
    const type = item.Spazio_tipo?.trim();
    if (!tiposAtivos.has(type)) continue;

    const labelExists = labelsAtivas.has(spazioId);

    const x = +item.Spazio_coord_draw_a / 100;
    const y = +item.Spazio_coord_draw_b / 100;
    const z = +item.Spazio_coord_draw_c / 100;
    const width = +item.Spazio_coord_largo / 100;
    const height = +item.Spazio_coord_alto / 100;
    const depth = +item.Spazio_coord_fondo / 100;

    const posY = item.Spazio_coord_alto === "0.001" ? 0 : y + height;
    _vector.set(x + width / 2, posY, z + depth / 2);

    const inView = _frustum.containsPoint(_vector);
    const distance = topCamera.position.distanceTo(_vector);

    let maxDistance = corridorSet.has(spazioId) ? 550 : 50;

    if (!inView || distance >= maxDistance) {
      if (labelExists) {
        const obj = labelsAtivas.get(spazioId);
        scene.remove(obj.labelObj.parent);
        obj.labelObj.element.remove();
        labelsAtivas.delete(spazioId);
      }
      continue;
    }

    const limite = tipoValorMap.get(type) || 0;
    const nomeLimitado = limite > 0 ? item.Spazio.slice(0, limite) : item.Spazio;

    let coordAlto = item.Spazio_coord_alto;
    if (
      (item.Spazio_classe === "04" && !racksSet.has(spazioId)) ||
      item.Spazio_classe === "03" ||
      item.Spazio_classe === "10"
    ) {
      coordAlto = "0.001";
    }

    const alvo = {
      ...item,
      Spazio: nomeLimitado,
      Spazio_coord_alto: coordAlto
    };

    if (!labelExists) {
      const labelObj = addLabelForSingleComponent(alvo, type);
      if (labelObj) {
        labelsAtivas.set(spazioId, { labelObj, tipo: type });
      }
    }
  }
}

 
function mirrorDataXCoordinates(data) {
        const centerX = getLayoutCenterX(data);

        const mirrorArray = (arr) => {
          arr?.forEach((item) => {
            let x = parseFloat(item.Spazio_coord_draw_a || "0");
            let width = parseFloat(item.Spazio_coord_largo || "0");
            let depth = parseFloat(item.Spazio_coord_fondo || "0");

            const orientation = String(item.Spazio_orientamento || "").trim();

            // Flip width/depth if orientation is along X
            if (orientation === "1") {
              [width, depth] = [depth, width];
            }

            const objectCenterX = x + width / 2;
            const mirroredCenterX = 2 * centerX - objectCenterX;

            item.Spazio_coord_draw_a = (mirroredCenterX - width / 2).toFixed(2);
          });
        };

        mirrorArray(data);
      }

      function getLayoutCenterX(data) {
        const allX = [
          ...data
        ]

          .map((item) => parseFloat(item.Spazio_coord_draw_a))
          .filter((x) => !isNaN(x));

        const minX = Math.min(...allX);
        const maxX = Math.max(...allX);
        return (minX + maxX) / 2;
      }

 

 
      function addGridWithFloorBounds(adjustedMin, adjustedMax) {
        const width = adjustedMax.x - adjustedMin.x;
        const depth = adjustedMax.z - adjustedMin.z;
        const centerX = (adjustedMin.x + adjustedMax.x) / 2;
        const centerZ = (adjustedMin.z + adjustedMax.z) / 2;

        const gridStep = 15;
        const gridSize = Math.max(width, depth);
        const gridDivisions = Math.floor(gridSize / gridStep); // 5 metros por célula (ajustável)

        const gridHelper = new THREE.GridHelper(
          gridSize,
          gridDivisions,
          0x888888, // cor igual para eixos centrais e secundários
          0x888888
        );

        gridHelper.position.set(centerX, -0.01, centerZ); // Abaixo de tudo
        gridHelper.material.depthWrite = false;
        gridHelper.material.transparent = true;
        gridHelper.renderOrder = -9999; // <--- sempre atrás

        scene.add(gridHelper);
      }

      async function extractDataFromJSON(data) {
        // Filtros por classe
        const classeExec = data.filter((d) => d.Spazio_classe === "01"); // Execução DONE
        const classeArmaz = data.filter((d) => d.Spazio_classe === "02"); // Armazenamento DONE
        const classeDocks = data.filter((d) => d.Spazio_classe === "03"); // Cais DONE
        const classeDivEspacos = data.filter((d) => d.Spazio_classe === "04"); // Divisões Espaços
        const classeZoneAnom = data.filter((d) => d.Spazio_classe === "05"); // Zonas Anómalas(RF)
        const classeDist = data.filter((d) => d.Spazio_classe === "06"); // Estações de Loja DONE
        const classeTransporte = data.filter((d) => d.Spazio_classe === "07"); // Transportes Not To Be Done
        const classeTransicao = data.filter((d) => d.Spazio_classe === "08"); // Zonas de Transição DONE
        const classeStacks = data.filter((d) => d.Spazio_classe === "09"); // Pilha DONE
        const classeTempDocks = data.filter((d) => d.Spazio_classe === "10"); // Cais temporário DONE

        // --- CALCULA BOUNDS E DESENHA SÓ A GRID, sem alterar a câmara ---
        const todosEspacosParaGrid = [
          ...classeDivEspacos,
          ...classeExec,
          ...classeDocks,
          ...classeStacks,
          ...classeTransporte,
          ...classeArmaz,
          ...classeDist,
          ...classeTempDocks,
          ...classeTransicao,
        ];

        const boundsBox = new THREE.Box3();

        todosEspacosParaGrid.forEach((item) => {
          const x = parseFloat(item.Spazio_coord_draw_a || 0) / 100;
          const y = parseFloat(item.Spazio_coord_draw_b || 0) / 100;
          const z = parseFloat(item.Spazio_coord_draw_c || 0) / 100;

          let width = parseFloat(item.Spazio_coord_largo || 100) / 100;
          let height = parseFloat(item.Spazio_coord_alto || 100) / 100;
          let depth = parseFloat(item.Spazio_coord_fondo || 100) / 100;

          const orientation = String(item.Spazio_orientamento || "").trim();
          if (orientation === "1") [width, depth] = [depth, width];

          const min = new THREE.Vector3(x, y, z);
          const max = new THREE.Vector3(x + width, y + height, z + depth);

          boundsBox.expandByPoint(min);
          boundsBox.expandByPoint(max);
        });

        const margem = 10;
        const adjustedMin = boundsBox.min.clone().subScalar(margem);
        const adjustedMax = boundsBox.max.clone().addScalar(margem);

        // Chama a função que já existe no teu projeto para adicionar a grid
        addGridWithFloorBounds(adjustedMin, adjustedMax);

        // Bounding box com base nas racks
        const relevantWalls = classeDivEspacos.filter(
          (e) => parseFloat(e.Spazio_coord_alto) !== 0
        );

        wallBoundingBoxCoords = calculateWallBoundingBox(relevantWalls);
        boundingBoxCenter.copy(wallBoundingBoxCoords.center);

        playerCollider.start.set(
          boundingBoxCenter.x,
          0.35,
          boundingBoxCenter.z
        );
        playerCollider.end.set(boundingBoxCenter.x, 1, boundingBoxCenter.z);

        camera.position.copy(playerCollider.end);
        camera.rotation.set(0, Math.PI, 0);

        orbitControls.target.set(boundingBoxCenter.x, 50, boundingBoxCenter.z);

        // Chamada das funções com os dados corretos
        // await createSpacesFromJSON(classeExec); //GM
        // await createWarehouseSpacesFromJSON(classeArmaz); // GM
        // await createDockFromJSON(classeDocks); //GM
        // await createAnomalousZonesFromJSON(classeZoneAnom); // GM
        // await createDistributionFromJSON(classeDist); // <- GM
        // await createTransitionZonesFromJSON(classeTransicao); // GM
        // await createStacksFromJSON(classeStacks); // GM
        // await createTemporaryDockFromJSON(classeTempDocks); //GM
        // await processDivSpacesClass(classeDivEspacos);

        generateDynamicLegend(data); // GM legendas
        createWarehouseAreaFromComponentsAll();

        // gerarMenuToggleLabels(
        //   classeDivEspacos,
        //   classeExec,
        //   classeDocks,
        //   classeStacks,
        //   classeTransporte,
        //   classeArmaz,
        //   classeDist,
        //   classeZoneAnom,
        //   classeTempDocks
        // );
        //createWarehouseAreaFromComponentsAll();
        // gerarMenuToggleLabels(
        //   classeDivEspacos,
        //   classeExec,
        //   classeDocks,
        //   classeStacks,
        //   classeTransporte,
        //   classeArmaz,
        //   classeTempDocks,
        //   classeDist
        // );
        // addFlatLabelsToWarehouse();
        // applyInitialLabelVisibilityFromMenu();

        EspacosAll = [
          ...classeDivEspacos,
          ...classeExec,
          ...classeDocks,
          ...classeStacks,
          ...classeTransporte,
          ...classeArmaz,
          ...classeDist,
          ...classeZoneAnom,
          ...classeTempDocks,
          ...classeTransicao,
        ];

        EspacosAll.forEach((item) => {
          const tipo = item.Spazio_tipoD?.trim();

          if (!EspacosPorTipoD[tipo]) {
            EspacosPorTipoD[tipo] = [];
          }

          EspacosPorTipoD[tipo].push(item);
        });

        createEmployee();
        const deltaTime = Math.min(0.05, clock.getDelta()) / STEPS_PER_FRAME;
        return {
          classeDivEspacos,
          classeExec,
          classeDocks,
          classeStacks,
          classeTransporte,
          classeArmaz,
          classeDist,
          classeZoneAnom,
          classeTempDocks,
        };
      }

function gerarMenuToggleLabels(...listas) {
  const tiposMap = new Map(); // tipo => label

  listas.flat().forEach((item) => {
    const tipo = item.Spazio_tipo?.trim() || "Desconhecido";
    const label = item.Spazio_tipoD?.trim() || tipo;
    if (!tiposMap.has(tipo)) {
      tiposMap.set(tipo, label);
    }
  });

  tiposMap.forEach((label, tipo) => {
    const allSections = document.querySelectorAll("#espacos-content > details");
    const section = [...allSections].find(
      (s) => s.querySelector("summary span span")?.textContent === label
    );

    if (!section) return;

    let ul = section.querySelector("ul");
    if (!ul) {
      ul = document.createElement("ul");
      section.appendChild(ul);
    }

    const li = document.createElement("li");
    const input = document.createElement("input");
    input.type = "checkbox";
    input.className = "label-toggle";
    input.id = `toggle-label-${tipo}`;
    input.value = tipo;

    const labelElement = document.createElement("label");
    labelElement.appendChild(input);
    labelElement.append(label, " ", "Label"); //TRADUÇÃO

    li.appendChild(labelElement);
    ul.appendChild(li);
  });
document.querySelectorAll(".label-toggle").forEach((checkbox) => {
 
 checkbox.addEventListener("change", (e) => {
  const type = e.target.value;
  const isVisible = e.target.checked;

  if (isVisible) {
    tiposAtivos.add(type);
  } else {
    tiposAtivos.delete(type);

    // Remove todas as labels do tipo da cena e do DOM
    [...labelsAtivas.entries()].forEach(([spazioId, obj]) => {
      if (obj.tipo === type) {
        scene.remove(obj.labelObj.parent); // dummy com a label
        obj.labelObj.element.remove(); // <div>
        labelsAtivas.delete(spazioId);
      }
    });
  }
});

});

 
  const deltaTime = Math.min(0.05, clock.getDelta()) / STEPS_PER_FRAME;
  return { listas };
}


const tiposValores = [];

function gerarMenuSizeSpazioId(...listas) {
  const tiposMap = new Map(); 

  listas.flat().forEach((item) => {
    const tipo = item.Spazio_tipo?.trim() || "Desconhecido";
    const label = item.Spazio_tipoD?.trim() || tipo;
    if (!tiposMap.has(tipo)) {
      tiposMap.set(tipo, label);
    }
  });

  tiposMap.forEach((label, tipo) => {
    const allSections = document.querySelectorAll("#espacos-content > details");
    const section = [...allSections].find(
      (s) => s.querySelector("summary span span")?.textContent === label
    );

    if (!section) return;

    let ul = section.querySelector("ul");
    if (!ul) {
      ul = document.createElement("ul");
      section.appendChild(ul);
    }

    const li = document.createElement("li");

    const labelElement = document.createElement("label");
    labelElement.style.display = "flex";
    labelElement.style.alignItems = "center";
    labelElement.style.gap = "10px";


    const inputNumber = document.createElement("input");
    inputNumber.type = "number";
    inputNumber.min = "0";
    inputNumber.step = "1";
    inputNumber.value = "";
    inputNumber.className = "buffer-select spazioid"; // aplica estilo coerente
    inputNumber.setAttribute("data-tipo", tipo); 
    labelElement.append(`Id`);
    labelElement.appendChild(inputNumber);

    li.appendChild(labelElement);
    ul.appendChild(li);
  });

  document.querySelectorAll("input.buffer-select.spazioid").forEach((input) => {
  const tipo = input.dataset.tipo;
  const valor = input.value;
   tiposValores.push({ tipo, valor });
  
  });

  document.querySelectorAll("input.buffer-select.spazioid").forEach((input) => {
    input.addEventListener("input", () => {
      const tipo = input.dataset.tipo;
      const valor = input.value;

      // Verifica se tipo já está no array
      const existente = tiposValores.find(obj => obj.tipo === tipo);

      if (existente) {
        existente.valor = valor; // atualiza valor existente
      } else {
        tiposValores.push({ tipo, valor }); // adiciona novo
      }


    });
  });
  const deltaTime = Math.min(0.05, clock.getDelta()) / STEPS_PER_FRAME;
  return { listas };
}

 
const bufferLevelsByTipo = new Map(); // Global — guarda níveis por tipo

 function encontrarObjetos3D(tipo, grupos) {
   
  for (const group of grupos) {
    for (const child of group.children) {
      const espacos = child.userData?.espacos || [];
      const possuiTipo = espacos.some(
        (item) => (item.Spazio_tipo || "").trim() === tipo
      );
      if (possuiTipo) {
        return child; // retorna a primeira instância encontrada
      }
    }
  }
  return null;
}

 

 function agruparEspacosEmNiveis(espacos) {
  const restantes = [...espacos].sort(
    (a, b) => a.base - b.base || a.topo - b.topo
  );
  const niveis = [];

  while (restantes.length > 0) {
    const primeiro = restantes[0]; // menor base
    const topoLimite = primeiro.topo;

    // Agrupa todos que começam antes do fim desse primeiro
    const nivelAtual = restantes.filter(e => e.base <= topoLimite);

    // Remove os agrupados
    for (const e of nivelAtual) {
      const idx = restantes.indexOf(e);
      if (idx !== -1) restantes.splice(idx, 1);
    }

    niveis.push(nivelAtual);
  }

  return niveis;
}


      function createSelectsLevels() {
        if (!Array.isArray(EspacosAll) || EspacosAll.length === 0) {
          console.warn("EspacosAll está vazio ou não é um array.");
          return;
        }

        const tiposMap = new Map();
         
        EspacosAll.forEach((espaco) => {
          const tipo = (espaco.Spazio_tipo || "Desconhecido").trim();
          const nome = (espaco.Spazio_tipoD || tipo).trim();

          if (!tiposMap.has(tipo)) {
            tiposMap.set(tipo, { nome, objetos: [] });
          }
          tiposMap.get(tipo).objetos.push(espaco);
        });

        const grupos = [
          rackGroup,
          corridorGroup,
          bufferGroup,
          spaceGroup,
          dockGroup,
          stackGroup,
          driveInGroup,
          anomalousGroup,
          distribGroup,
          transitionGroup,
          tempDockGroup,
        ];

        tiposMap.forEach(({ nome, objetos }, tipo) => {
           
 
        const meshPai = encontrarObjetos3D(tipo, grupos);
        if (!meshPai || !meshPai.userData?.espacos) return; // <-- aqui substitui o "continue"



        const espacosData = [];

        const espacos = meshPai.userData?.espacos || [];

          espacos.forEach((obj, index) => {
            if ((obj.Spazio_tipo || "").trim() === tipo) {
              const base = parseFloat(obj.Spazio_coord_draw_b || 0);
              const altura = parseFloat(obj.Spazio_coord_alto || 0);
              const topo = base + altura;

              espacosData.push({
                base,
                topo,
                altura,
                tipo: obj.Spazio_tipo,
                tipoD: obj.Spazio_tipoD,
                spazio: obj.Spazio,
                classe:obj.Spazio_classe,
                index,         
              });
            }
          });

           
          const niveis = agruparEspacosEmNiveis(espacosData);
          niveis.meshPai = meshPai;

            
          bufferLevelsByTipo.set(tipo, niveis);
   
        });
      }

   function gerarSelectsBufferPorTipo(...listas) {
  const tiposMap = new Map();

  listas.flat().forEach((item) => {
    const tipo = (item.Spazio_tipo || "Desconhecido").trim();
    const nome = (item.Spazio_tipoD || tipo).trim();
    if (!tiposMap.has(tipo)) {
      tiposMap.set(tipo, { nome, objetos: [] });
    }
    tiposMap.get(tipo).objetos.push(item);
  });

  const allSections = document.querySelectorAll("#espacos-content > details");

  tiposMap.forEach(({ nome, objetos }, tipo) => {
    const espacosData = objetos.map((obj) => {
      const base = parseFloat(obj.Spazio_coord_draw_b || 0);
      const altura = parseFloat(obj.Spazio_coord_alto || 0);
      const topo = base + altura;
      return { base, topo, altura, tipo: obj.Spazio_tipo };
    });

    const niveis = agruparEspacosEmNiveis(espacosData);
    const section = [...allSections].find(
      (s) => s.querySelector("summary span span")?.textContent === nome
    );
    if (!section) return;

    const wrapper = document.createElement("div");
    wrapper.className = "dropdown-group";

    const details = document.createElement("details");
    details.className = "dropdown-group";

    const summary = document.createElement("summary");
    summary.textContent = `Níveis (${niveis.length})`;
    details.appendChild(summary);

    const ul = document.createElement("ul");

    const selectedLevels = new Set(niveis.map((_, i) => i));

    niveis.forEach((_, nivelIndex) => {
      const li = document.createElement("li");
      const label = document.createElement("label");

      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = true;
      checkbox.dataset.tipo = tipo;
      checkbox.dataset.nivel = nivelIndex;

      checkbox.addEventListener("change", () => {
        const nivel = parseInt(checkbox.dataset.nivel);
        checkbox.checked
          ? selectedLevels.add(nivel)
          : selectedLevels.delete(nivel);

        updateBufferLevelsPorTipoCheckbox(tipo, selectedLevels);
      });

      label.appendChild(checkbox);
      label.append(` Nível ${nivelIndex + 1}`);
      li.appendChild(label);
      ul.appendChild(li);
    });

    details.appendChild(ul);
    wrapper.appendChild(details);
    section.appendChild(wrapper);
  });
}

  function corrigirNiveisEspacos(niveis) {
        let mudou;

        do {
          mudou = false;

          for (let i = 1; i < niveis.length; i++) {
            const nivelAnterior = niveis[i - 1];
            const nivelAtual = niveis[i];

            const topoAnterior = Math.max(...nivelAnterior.map((e) => e.topo));

            // Separar elementos válidos e inválidos
            const invalidos = nivelAtual.filter((e) => e.base < topoAnterior);

            if (invalidos.length > 0) {
              // Remover do nível atual e colocar no anterior
              niveis[i] = nivelAtual.filter((e) => e.base >= topoAnterior);
              niveis[i - 1].push(...invalidos);
              mudou = true;
              break; // reinicia o processo após qualquer alteração
            }
          }
        } while (mudou);

        return niveis;
      }

function updateBufferLevelsPorTipoCheckbox(tipo, niveisSelecionados) {
  const niveis = bufferLevelsByTipo.get(tipo);
  if (!niveis || !niveis.meshPai) return;

  const mesh = niveis.meshPai;
  const dummy = new THREE.Object3D();

  for (let i = 0; i < niveis.length; i++) {
    const isVisible = niveisSelecionados.has(i);

    const nivel = niveis[i];
    nivel.forEach((espaco) => {
      const index = espaco.index;
      const classe = espaco.classe;
      if (typeof index !== "number" || !classe) return;

      mesh.getMatrixAt(index, dummy.matrix);
      dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);

      if (!isVisible) {
        dummy.scale.set(0.0001, 0.0001, 0.0001); // hide
      } else {
        const original = originalScalesByClasse[classe]?.[index];
        if (original) {
          dummy.scale.set(original.x, original.y, original.z); // restore
        }
      }

      dummy.updateMatrix();
      mesh.setMatrixAt(index, dummy.matrix);
    });
  }

  mesh.instanceMatrix.needsUpdate = true;
}

      function processDivSpacesClass(componentes) {
        const tiposMap = {};

        // Agrupar por tipo de espaço
        componentes.forEach((item) => {
          const tipo = item.Spazio_tipo;
          if (!tiposMap[tipo]) {
            tiposMap[tipo] = [];
          }
          tiposMap[tipo].push(item);
        });

        // Processar cada grupo

        for (const tipo in tiposMap) {
          const grupo = tiposMap[tipo];

          // Criar visual inicial baseado na altura do 1º item
          const temAltura = grupo.some((item) => {
            if (!item || item.Spazio_coord_alto == null) return false;
            return parseFloat(item.Spazio_coord_alto) > 0.001;
          });
          if (temAltura) {
            createRacksFromJSON(grupo);
          } else {
            createCorridorsFromJSON(grupo);
          }


        }

      }

      //Nova função realizada por GM para representar os espaços
async function createCorridorsFromJSON(corridors) {
  const shrinkFactor = 1;
  const geometry = new THREE.BoxGeometry(1, 1, 1);
  const dummy = new THREE.Object3D();
  const count = corridors.length;
  const defaultColor = new THREE.Color("#3399ff");

  const tipoD = corridors[0]?.Spazio_tipoD || "unknown";

  // Limpa anteriores
  corridorGroup.children
    .filter(child => child.userData?.tipoD === tipoD)
    .forEach(child => {
      corridorGroup.remove(child);
      child.geometry?.dispose?.();
      if (Array.isArray(child.material)) {
        child.material.forEach(m => m.dispose?.());
      } else {
        child.material?.dispose?.();
      }
    });

  // Outline group
  const outlineGroup = new THREE.Group();

  // Material instanciado invisível (pode ser ajustado)
  const material = new THREE.MeshBasicMaterial({
    color: defaultColor,
    transparent: false,
    opacity: 1,
  });

  const outlineMaterial = new THREE.LineBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 1,
  });

  const instancedMesh = new THREE.InstancedMesh(geometry, material, count);
  instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
  instancedMesh.frustumCulled = false;

  const color = new THREE.Color();
  const colorArray = new Float32Array(count * 3);

  for (let i = 0; i < corridors.length; i++) {
    const c = corridors[i];

    let width = parseFloat(c.Spazio_coord_largo || 100) / 100;
    let depth = parseFloat(c.Spazio_coord_fondo || 100) / 100;
    const x = parseFloat(c.Spazio_coord_draw_a || 0) / 100;
    const z = parseFloat(c.Spazio_coord_draw_c || 0) / 100;
    const orientation = String(c.Spazio_orientamento || "").trim();
    if (orientation === "1") [width, depth] = [depth, width];

    const posX = x + width / 2;
    const posY = 0;
    const posZ = z + depth / 2;

    // Instanced mesh
    dummy.position.set(posX, posY, posZ);
    dummy.scale.set(width * shrinkFactor, 0.01 * shrinkFactor, depth * shrinkFactor);
    dummy.updateMatrix();
    instancedMesh.setMatrixAt(i, dummy.matrix);

    // Cor
    try {
      color.set("#" + c.Colore_Html || "#3399ff");
    } catch {
      color.copy(defaultColor);
    }
    color.toArray(colorArray, i * 3);

    // Outline individual
    const boxGeo = new THREE.BoxGeometry(width * shrinkFactor, 0.01 * shrinkFactor, depth * shrinkFactor);
    const edgeGeo = new THREE.EdgesGeometry(boxGeo);
    const outline = new THREE.LineSegments(edgeGeo, outlineMaterial.clone());
    outline.position.set(posX, posY, posZ);
    outline.visible = false;
    outline.frustumCulled = false;

    outline.userData.tipo = c.Spazio_tipo;
    outline.userData.tipoD = c.Spazio_tipoD;
    outline.userData.spazio_disp = c.Spazio_disponibile;

    outlineGroup.add(outline);
    outlinesArray.push({
      outline,
      position: outline.position.clone(),
    });

 
  }

  instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(colorArray, 3);
  instancedMesh.instanceMatrix.needsUpdate = true;

  instancedMesh.userData.espacos = [...corridors];
  instancedMesh.userData.tipoD = tipoD;
  instancedMesh.userData.tipo = corridors[0]?.Spazio_tipo;

  outlineGroup.userData.tipo = corridors[0]?.Spazio_tipo;
  outlineGroup.userData.tipoD = tipoD;
  outlineGroup.userData.spazio_disp = corridors[0]?.Spazio_disponibile;

  corridorGroup.add(instancedMesh);
  corridorGroup.add(outlineGroup);

  classeDivEspacosMeshes = classeDivEspacosMeshes.filter(m => m.userData?.tipoD !== tipoD);
  classeDivEspacosMeshes.push(instancedMesh);

  console.log(`Corredores desenhados (classe 05): ${count}`);
}

 function applyInitialLabelVisibilityFromMenu() {
        document.querySelectorAll(".label-toggle").forEach((checkbox) => {
          const type = checkbox.value;
          const visible = checkbox.checked;
          const labels = labelRenderer.domElement.querySelectorAll(
            `.toggle-label-${type}`
          );
          labels.forEach((el) => {
            el.style.visibility = visible ? "visible" : "hidden";
          });
        });
      }

      //NEW FUNCTIONS FOR DYNAMIC SIDE BAR ---------------------------------------------------------------------------
      async function toggleLayoutVisibility(spazioTipoDLabel, isVisible) {
        const allGroups = {
          "01": spaceGroup,
          "02": bufferGroup,
          "03": dockGroup,
          "04": [corridorGroup, rackGroup],
          "05": anomalousGroup,
          "06": distribGroup,
          "08": transitionGroup,
          "09": stackGroup,
          "10": tempDockGroup,
        };
          
        const filteredItems = EspacosPorTipoD[spazioTipoDLabel];
        if (!filteredItems || filteredItems.length === 0) {
          console.warn("Nenhum item com Spazio_tipoD =", spazioTipoDLabel);
          return;
        }

        const targetClasses = [
          ...new Set(filteredItems.map((i) => i.Spazio_classe)),
        ];

        for (const targetClass of targetClasses) {
          const itemsDaClasse = filteredItems.filter(
            (i) => i.Spazio_classe === targetClass
          );

          const targetGroups = Array.isArray(allGroups[targetClass])
            ? allGroups[targetClass]
            : [allGroups[targetClass]];

          // Só desenha se ainda não estiver desenhado este tipo específico
          const alreadyDrawn = targetGroups.some((g) =>
            g.children.some((c) => c.userData?.tipoD === spazioTipoDLabel)
          );

          if (isVisible && !alreadyDrawn) {
             

            switch (targetClass) {
              case "01":
                await createSpacesFromJSON(itemsDaClasse);
                break;
              case "02":
                await createWarehouseSpacesFromJSON(itemsDaClasse);
                break;
              case "03":
                await createDockFromJSON(itemsDaClasse);
                break;
              case "04":
                await processDivSpacesClass(itemsDaClasse);
                break;
              case "05":
                await createAnomalousZonesFromJSON(itemsDaClasse);
                break;
              case "06":
                await createDistributionFromJSON(itemsDaClasse);
                break;
              case "08":
                await createTransitionZonesFromJSON(itemsDaClasse);
                break;
              case "09":
                await createStacksFromJSON(itemsDaClasse);
                break;
              case "10":
                await createTemporaryDockFromJSON(itemsDaClasse);
                break;
            }
            createSelectsLevels();
          }

            

          // Atualiza visibilidade (escala) das instâncias desenhadas
          const dummy = new THREE.Object3D();
          targetGroups.forEach((group) => {
            if (!group) return;

            group.children.forEach((child) => {
              if (
                child.isInstancedMesh &&
                Array.isArray(child.userData?.espacos)
              ) {
                const espacos = child.userData.espacos;

                for (let i = 0; i < espacos.length; i++) {
                  const item = espacos[i];
                  if (
                    item.Spazio_classe === targetClass &&
                    item.Spazio_tipoD === spazioTipoDLabel
                  ) {
                    child.getMatrixAt(i, dummy.matrix);
                    dummy.matrix.decompose(
                      dummy.position,
                      dummy.quaternion,
                      dummy.scale
                    );
                    
                     
                    const original = originalScalesByClasse[targetClass]?.[i];
                    const scale = isVisible
                      ? original || dummy.scale
                      : { x: 0.0001, y: 0.0001, z: 0.0001 };

                    dummy.scale.set(scale.x, scale.y, scale.z);
                    dummy.updateMatrix();
                    child.setMatrixAt(i, dummy.matrix);
                  }
                }



                child.instanceMatrix.needsUpdate = true;
              } else if (
                child.isLineSegments &&
                child.userData?.tipoD === spazioTipoDLabel
              ) {
                child.visible = isVisible;
              }
            });
          });

          // Atualiza contornos (outlines)
          outlinesArray.forEach(({ outline }) => {
            if (outline.userData?.tipoD === spazioTipoDLabel) {
              outline.visible = isVisible;
              outline.userData.hiddenByLayout = !isVisible;
            }
          });
 
        }
      }

      function toggleActiveSpaces(tipoD, isChecked, data) {
        const allGroups = {
          "01": spaceGroup,
          "02": bufferGroup,
          "03": dockGroup,
          "05": anomalousGroup,
          "06": distribGroup,
          "08": transitionGroup,
          "09": stackGroup,
          "10": tempDockGroup,
        };

        const filteredItems = data.filter(
          (item) => item.Spazio_tipoD === tipoD
        );
        if (filteredItems.length === 0) return;

        const targetClass = filteredItems[0].Spazio_classe;
        const targetGroup = allGroups[targetClass];
        if (!targetGroup) return;

        const instancedMesh = targetGroup.children.find(
          (child) => child.isInstancedMesh
        );
        if (!instancedMesh) return;

        const color = new THREE.Color();

        filteredItems.forEach((item, i) => {
          if (item.Spazio_classe !== targetClass) return;

          let cor;
          if (isChecked && item.Spazio_disponibile === "0") {
            cor = "#ff0000"; // indisponível → pinta de vermelho
          } else {
            cor = item.ColoreD; // original ou fallback
          }

          try {
            color.set(cor.toLowerCase());
          } catch (e) {
            color.set("#aaaaaa"); // fallback se inválida
          }

          instancedMesh.setColorAt(i, color);
        });

        instancedMesh.instanceColor.needsUpdate = true;
 
      }

function toggleHeight2D(tipoD, isChecked, data) {
  const allGroups = {
    "01": spaceGroup,
    "02": bufferGroup,
    "03": dockGroup,
    "05": anomalousGroup,
    "06": distribGroup,
    "08": transitionGroup,
    "09": stackGroup,
    "10": tempDockGroup,
  };

  const filteredItems = data.filter(item => item.Spazio_tipoD === tipoD);
  if (filteredItems.length === 0) return;

  const targetClasses = [...new Set(filteredItems.map(item => item.Spazio_classe))];

  targetClasses.forEach(targetClass => {
    if (targetClass === "04") {
        
      // ✅ Remoção de corredores/racks por tipoD sem traverse

      const clearGroupByTipoD = (group) => {
        // 1. Remover objetos com tipoD do grupo
        const toRemove = group.children.filter(child => child.userData?.tipoD === tipoD);
        toRemove.forEach(child => {
          group.remove(child);
          child.geometry?.dispose?.();
          if (Array.isArray(child.material)) {
            child.material.forEach(mat => mat.dispose?.());
          } else {
            child.material?.dispose?.();
          }
        });

        // 2. Remover outlines com tipoD do grupo e do array
        for (let i = outlinesArray.length - 1; i >= 0; i--) {
          const obj = outlinesArray[i];
          if (obj.outline?.userData?.tipoD === tipoD) {
            if (group.children.includes(obj.outline)) {
              group.remove(obj.outline);
            }
            obj.outline.geometry?.dispose?.();
            obj.outline.material?.dispose?.();
            outlinesArray.splice(i, 1);
          }
        }
      };

 

     
    clearGroupByTipoD(rackGroup);
    clearGroupByTipoD(corridorGroup);
      // Limpa também array auxiliar sem traverse
      classeDivEspacosMeshes = classeDivEspacosMeshes.filter(mesh => {
        if (mesh.userData?.tipoD === tipoD) {
          mesh.geometry?.dispose?.();
          mesh.material?.dispose?.();
          return false;
        }
        return true;
      });

      // ⚡ Só executa criação quando necessário
      if (isChecked) {
      createCorridorsFromJSON(filteredItems);
      } else {
        createRacksFromJSON(filteredItems);
      }
      

      return;
    }

    // Demais classes (com InstancedMesh)
    const targetGroups = Array.isArray(allGroups[targetClass])
      ? allGroups[targetClass]
      : [allGroups[targetClass]];

    const dummy = new THREE.Object3D();

    targetGroups.forEach(group => {
      group.children.forEach(child => {
        if (!child.isInstancedMesh || !Array.isArray(child.userData?.espacos)) return;

        const espacos = child.userData.espacos;
        let changed = false;

        for (let i = 0; i < espacos.length; i++) {
          const item = espacos[i];
          if (item.Spazio_tipoD !== tipoD) continue;

          child.getMatrixAt(i, dummy.matrix);
          dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);

          const original = originalScalesByClasse[targetClass]?.[i];
          const newY = isChecked ? 0.001 : original?.y ?? dummy.scale.y;

          if (dummy.scale.y !== newY) {
            dummy.scale.y = newY;
            dummy.updateMatrix();
            child.setMatrixAt(i, dummy.matrix);
            changed = true;
          }
        }

        if (changed) {
          child.instanceMatrix.needsUpdate = true;
        }
      });
    });

    // ✅ Toggle outlines sem traverse
    outlinesArray.forEach(({ outline }) => {
      if (outline.userData?.tipoD === tipoD) {
        outline.visible = !isChecked;
        outline.userData.hiddenByHeight2D = isChecked;
      }
    });
  });

  createSelectsLevels();
  console.log(`✔ Atualizado tipoD ${tipoD} para ${isChecked ? "achatado" : "normal"}`);
}


 
      function showLevels(tipo) {
        console.log("Show levels:", tipo);
      }

      function generateDynamicLegend(data) {
        const legendContainer = document.getElementById("legend-popup");
        legendContainer.innerHTML = "";

        const uniqueTypes = [...new Set(data.map((d) => d.Spazio_tipoD))];
        uniqueTypes.forEach((type) => {
          const sample = data.find((d) => d.Spazio_tipoD === type);
          let color = (sample?.ColoreD || "#ffffff").toLowerCase();

          // validate the color
          try {
            new THREE.Color(color);
          } catch {
            color = "#ffffff";
          }

          const item = document.createElement("div");
          item.className = "legend-item";
          item.innerHTML = `
            <div class="legend-color" style="background-color: ${color};"></div>
            ${type}
          `;
          legendContainer.appendChild(item);
        });
      }
      //END OF NEW FUNCTIONS FOR DYNAMIC SIDE BAR ---------------------------------------------------------------------------

     window.onload = async function () {
      translateConfig();
  const loader = document.getElementById("loader");

  try {
    const response = await fetch("resources/data/dados_limpo.json");
    const data = await response.json();

    trocarCoordenadasBC(data);
    mirrorDataXCoordinates(data)
    const val = await extractDataFromJSON(data);

    labelRenderer.setSize(window.innerWidth, window.innerHeight);
    labelRenderer.domElement.style.position = "absolute";
    labelRenderer.domElement.style.top = "0px";
    labelRenderer.domElement.style.pointerEvents = "none";
    document.body.appendChild(labelRenderer.domElement);

    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setAnimationLoop(animate);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.VSMShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    container.appendChild(renderer.domElement);

    stats.domElement.style.position = "fixed";
    stats.domElement.style.bottom = "10px";
    stats.domElement.style.right = "10px";
    stats.domElement.style.left = "";
    stats.domElement.style.top = "";
    stats.domElement.style.zIndex = "9999";
    document.body.appendChild(stats.domElement);
    container.appendChild(stats.domElement);

            container.appendChild(stats.domElement);
            toggleCamera();

    const uniqueSpazioTipoD = [...new Set(data.map((d) => d.Spazio_tipoD))];
    const sidebarContainer = document.getElementById("sidebar-dynamic-container");

    const wrapper = document.createElement("details");
    wrapper.className = "dropdown-group";
    wrapper.open = false;
    wrapper.innerHTML = `
      <summary>
        <span style="display: flex; align-items: center; gap: 6px">
          <img src="three/ISRWarehouse3D/imgs/stack-light.svg" class="phosphor-icon">
          <span>SPACES</span>
        </span>
      </summary>
      <div id="espacos-content"></div>
    `;
    sidebarContainer.appendChild(wrapper);

    const espacosContent = wrapper.querySelector("#espacos-content");

    uniqueSpazioTipoD.forEach((tipo) => {
      const section = document.createElement("details");
      section.className = "dropdown-group";
      section.innerHTML = `
        <summary>
          <span style="display: flex; align-items: center; gap: 6px">
            <img src="three/ISRWarehouse3D/imgs/cube-light.svg" class="phosphor-icon">
            <span>${tipo}</span>
          </span>
        </summary>
        <ul>
          <li><label><input type="checkbox" class="toggle-layout" data-tipo="${tipo}"  /> Layout</label></li>
          <li><label><input type="checkbox" class="toggle-active" data-tipo="${tipo}"  /> Check Availability </label></li>
          <li><label><input type="checkbox" class="toggle-height" data-tipo="${tipo}" /> Flatten Height (2D)</label></li>
        </ul>
      `;
      espacosContent.appendChild(section);
    });

    createSelectsLevels();
    gerarMenuToggleLabels(...EspacosAll);
    gerarSelectsBufferPorTipo(...EspacosAll);
    gerarMenuSizeSpazioId(...EspacosAll)

    document.addEventListener("change", (e) => {
      const tipo = e.target.dataset.tipo;
      if (e.target.classList.contains("toggle-layout")) {
        toggleLayoutVisibility(tipo, e.target.checked, data);
      } else if (e.target.classList.contains("toggle-active")) {
        toggleActiveSpaces(tipo, e.target.checked, data);
      } else if (e.target.classList.contains("toggle-height")) {
        toggleHeight2D(tipo, e.target.checked, data);
      }
    });

    document.addEventListener("click", (e) => {
      if (e.target.classList.contains("btn-levels")) {
        const tipo = e.target.dataset.tipo;
        showLevels(tipo);
      }
    });


const title = document.getElementById("ArmName");
const objComNome = data.find(item => item.EnteD && item.EnteD.trim() !== "");

if (title && objComNome) {
  title.textContent = objComNome.EnteD;            
  // title.textContent = `${t("Arm")} - ${objComNome.EnteD}`;
}

  } catch (error) {
    console.error("Erro ao carregar aplicação:", error);
    alert("Erro a carregar o armazém. Tenta recarregar a página.");
  } finally {
    loader.style.display = "none"; // oculta o loader mesmo que falhe
  }
};


      function trocarCoordenadasBC(array) {
        array.forEach((item) => {
          const temp = item.Spazio_coord_draw_b;
          item.Spazio_coord_draw_b = item.Spazio_coord_draw_c;
          item.Spazio_coord_draw_c = temp;
        });
      }

      function isNotHidden(obj) {
        if (obj.userData.hidden) return false;
        let parent = obj.parent;
        while (parent) {
          if (parent.userData && parent.userData.hidden) return false;
          parent = parent.parent;
        }
        return true;
      }

      // ToggleWarehouse
      document.getElementById("toggleWarehouseBtn").addEventListener("click", toggleWarehouse);
      //Tutorial button ALTERAÇAO GM
      const tutorialBtn = document.getElementById("tutorial-btn");
      const tooltipTutorial = document.getElementById("tutorial-tooltip");

      let isTooltipVisible = false;

      tutorialBtn.addEventListener("click", () => {
        isTooltipVisible = !isTooltipVisible;
        tooltipTutorial.classList.toggle("show", isTooltipVisible);
      });

      //Oculta se clicar fora
      document.addEventListener("click", (e) => {
        if (
          !tooltipTutorial.contains(e.target) &&
          !tutorialBtn.contains(e.target) &&
          isTooltipVisible
        ) {
          tooltipTutorial.classList.remove("show");
          isTooltipVisible = false;
        }
      });

      //SIDE BAR JS ALTERAÇÃO GM ---------------------------------------------------------------------------
      const sidebarToggle = document.getElementById("sidebar-toggle");
      const sidebar = document.getElementById("sidebar");

      let isSidebarVisible = true;

      sidebarToggle.addEventListener("click", () => {
        isSidebarVisible = !isSidebarVisible;

        if (isSidebarVisible) {
          sidebar.style.transform = "translateX(0)";
          sidebarToggle.innerHTML = "❮";
          sidebarToggle.style.left = "250px";
        } else {
          sidebar.style.transform = "translateX(-250px)";
          sidebarToggle.innerHTML = "❯";
          sidebarToggle.style.left = "0px";
        }
      });
      // FIM SIDE BAR JS ALTERAÇÃO GM ---------------------------------------------------------------------------

      //TOGGLE CAPTIONS JS ALTERAÇÃO GM
      const toggleCaptionsBtn = document.getElementById("toggle-captions-btn");
      const legendPopup = document.getElementById("legend-popup");

      //Toggle visibilidade
      toggleCaptionsBtn.addEventListener("click", () => {
        legendPopup.classList.toggle("hidden");
      });

      //Função drag
      let isDragging = false;
      let offsetX, offsetY;

      legendPopup.addEventListener("mousedown", (e) => {
        isDragging = true;
        offsetX = e.clientX - legendPopup.offsetLeft;
        offsetY = e.clientY - legendPopup.offsetTop;
      });
      document.addEventListener("mousemove", (e) => {
        if (isDragging) {
          legendPopup.style.left = `${e.clientX - offsetX}px`;
          legendPopup.style.top = `${e.clientY - offsetY}px`;
        }
      });

      document.addEventListener("mouseup", () => {
        isDragging = false;
      });
    </script>
  </body>
</html>
