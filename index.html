<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <title>three.js - misc - octree collisions</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link rel="stylesheet" href="main.css" />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <!-- HEADER NAVIGATION -->
    <div id="top-nav">
      <div class="nav-left">
        <img src="resources/imgs/Eve_Icon.png" class="logo" />
        <span class="title">Warehouse 3D</span>
      </div>
      <div class="nav-right">
        <button id="toggle-view-btn">2D</button>
        <button id="tutorial-btn">Tutorial</button>
      </div>
    </div>

    <div id="tutorial-tooltip">
      <strong>Controlers:</strong><br />
      "MOUSE 1" to look around <br />
      "WASD" to move <br />
      "T" to toggle freecam <br />
      "MOUSE SCROLL" to amplify
    </div>
    <div id="zoom-controls">
      <button id="zoom-in">+</button>
      <button id="zoom-out">−</button>
      <button id="reset-topcam">↺</button>
    </div>
    <!-- END OF HEADER NAVIGATION -->
    <div id="legend-popup" class="legend-popup hidden" draggable="true">
      <div class="legend-item">
        <div class="legend-color rack"></div>
        Racks (caixas azuis translúcidas)
      </div>
      <div class="legend-item">
        <div class="legend-color space"></div>
        Picking(verde)
      </div>
      <div class="legend-item">
        <div class="legend-color buffer"></div>
        Buffers (rosa)
      </div>
      <div class="legend-item">
        <div class="legend-color corridor"></div>
        classeTransportesMeshes (planos azuis semi-translúcidos)
      </div>

      <div class="legend-item">
        <div class="legend-color dock" style="background-color: #ffa500"></div>
        Cais (laranja)
      </div>
      <div class="legend-item">
        <div class="legend-color stack" style="background-color: #9966ff"></div>
        Pilhas (roxo)
      </div>
      <div class="legend-item">
        <div class="legend-color stack" style="background-color: #00ccff"></div>
        Drive In (roxo)
      </div>
    </div>

    <div
      id="tooltip"
      style="
        position: absolute;
        color: white;
        background: rgba(0, 0, 0, 0.8);
        padding: 6px 10px;
        border-radius: 5px;
        font-size: 14px;
        pointer-events: none;
        z-index: 999;
        display: none;
        font-family: sans-serif;
      "
    ></div>

    <div id="container"></div>
    <button id="sidebar-toggle">❮</button>

    <!-- Sidebar HTML -->
    <div id="sidebar">
      <h2 class="arm">Armazém Alpha</h2>

      <div class="section">
        <details class="dropdown-group" open>
          <summary>
            <span style="display: flex; align-items: center; gap: 6px">
              <i class="ph ph-layout"></i>
              <span>LAYOUT</span>
            </span>
          </summary>

          <ul>
            <li>
              <label
                ><input type="checkbox" value="racks" checked /> Racks</label
              >
            </li>
            <li>
              <label
                ><input type="checkbox" value="corridors" checked />
                Corredores</label
              >
            </li>
            <li>
              <label
                ><input type="checkbox" value="buffers" checked />
                Buffers</label
              >
            </li>
            <li>
              <label
                ><input type="checkbox" value="spaces" checked /> Picking</label
              >
            </li>
            <li>
              <label
                ><input type="checkbox" value="docks" checked /> Cais</label
              >
            </li>
            <li>
              <label
                ><input type="checkbox" value="stacks" checked /> Pilhas</label
              >
            </li>
            <li>
              <label
                ><input type="checkbox" value="driveins" checked />
                DriveIns</label
              >
            </li>
          </ul>
        </details>
      </div>

      <!-- DROPDOWN BUFFER LEVELS ESTILIZADO -->
      <details class="dropdown-group" open>
        <summary>
          <span style="display: flex; align-items: center; gap: 6px">
            <i class="ph ph-sliders-horizontal"></i>
            <span>BUFFER LEVELS</span>
          </span>
        </summary>

        <div id="buffer-level-container">
          <!-- Aqui entraremos dinamicamente -->
        </div>
      </details>

      <!-- CHECKBOX CAPTIONS SIMPLES E ALINHADO -->
      <details class="dropdown-group" open>
        <summary id="toggle-captions-btn">
          <span style="display: flex; align-items: center; gap: 6px">
            <i class="ph ph-warehouse"></i>
            <span>TOGGLE CAPTIONS</span>
          </span>
        </summary>
      </details>

      <details class="dropdown-group" open>
        <summary style="cursor: pointer">
          <span style="display: flex; align-items: center; gap: 6px">
            <i class="ph ph-tag"></i>
            <span>TOGGLE LABELS</span>
          </span>
        </summary>
        <ul id="label-toggle-list"></ul>
      </details>
    </div>

    <!-- FIM DO HTML DO SIDEBAR-->

    <script type="importmap">
      {
        "imports": {
          "three": "./three/build/three.module.js",
          "three/addons/": "./three/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import Stats from "three/addons/libs/stats.module.js";
      import { Octree } from "three/addons/math/Octree.js";
      import { OctreeHelper } from "three/addons/helpers/OctreeHelper.js";
      import { Capsule } from "three/addons/math/Capsule.js";
      import { GUI } from "three/addons/libs/lil-gui.module.min.js";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import {
        CSS2DRenderer,
        CSS2DObject,
      } from "./three/examples/jsm/renderers/CSS2DRenderer.js";

      const clock = new THREE.Clock();
      let wallBoundingBoxCoords;
      let racks;
      let spaces;
      let docks;
      let stacks;
      let driveIns;
      let corredor;
      let buffers;
      let boundingBoxCenter = new THREE.Vector3();
      let classeEspExecMeshes = []; // Add this at the top of your script
      let classeEspArmMeshes = [];
      let classeCaisMeshes = [];
      let classeDivEspacosMeshes = [];
      let classeZonAnomalasMeshes = [];
      let classeEspacoDistrMeshes = [];
      let classeTransportesMeshes = [];
      let classeTransicaoMeshes = [];
      let classePilhaMeshes = [];
      let classeCaisTemporarioMeshes = [];
      let outlinesArray = [];
      let EspacosAll = [];
      let hoveredInstance = null; // guarda instância ativa no hover

      const bufferOriginalScales = {}; // índice → escala real
 /// BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
      const scene = new THREE.Scene();
      //Mudança das core GM
      scene.background = new THREE.Color(0x252c3f);

      let instancedMesh;
      let bufferInstancedMesh = null;

      const camera = new THREE.PerspectiveCamera(
        70,
        window.innerWidth / window.innerHeight,
        0.1,
        10000
      );
      camera.position.set(50, 1, 50); // ou boundingBoxCenter quando disponível
      camera.rotation.set(0, 0, 0); // olhe para frente
      camera.up.set(0, 1, 0);

      camera.rotation.order = "YXZ";

      const topCamera = new THREE.PerspectiveCamera(
        20,
        window.innerWidth / window.innerHeight,
        1,
        10000
      );

      topCamera.position.set(50, 100, 50); // Starting high above the warehouse
      const initialTopCamPosition = new THREE.Vector3(50, 100, 50);
      const initialTopCamTarget = new THREE.Vector3(50, 0, -50);

      const angle = Math.PI; // 180 degrees

      const offset = new THREE.Vector3().subVectors(
        initialTopCamPosition,
        initialTopCamTarget
      );
      offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle); // rotate offset around Y

      const rotatedPosition = new THREE.Vector3().addVectors(
        initialTopCamTarget,
        offset
      );

      // Apply rotated position to topCamera
      topCamera.position.copy(rotatedPosition);
      topCamera.lookAt(initialTopCamTarget);

      // ---------- ORTHO (2D) CAMERA ----------
      const ORTHO_SIZE = 120; // “altura” do frustum – ajuste se necessário
      const aspect = window.innerWidth / window.innerHeight;

      const orthoCamera = new THREE.OrthographicCamera(
        (-ORTHO_SIZE * aspect) / 2, // left
        (ORTHO_SIZE * aspect) / 2, // right
        ORTHO_SIZE / 2, // top
        -ORTHO_SIZE / 2, // bottom
        1, // near
        10000 // far
      );
      orthoCamera.position.copy(rotatedPosition); // mesmo ponto de vista
      orthoCamera.lookAt(new THREE.Vector3(50, 0, -50)); // mesmo alvo

      const toggleViewBtn = document.getElementById("toggle-view-btn");
      let is2DView = false;

      toggleViewBtn.addEventListener("click", () => {
        is2DView = !is2DView;

        if (is2DView) {
          // Troca para ortográfica

          orthoCamera.position.copy(initialTopCamPosition);
          orthoCamera.lookAt(initialTopCamTarget);
          activeCamera = orthoCamera;
          toggleViewBtn.textContent = "3D";
          orbitControls.enableRotate = true;
        } else {
          // Volta para a topCamera
          activeCamera = topCamera;
          toggleViewBtn.textContent = "2D";
          orbitControls.enableRotate = true;
        }

        orbitControls.object = activeCamera;
        orbitControls.update();
      });

      // Zoom control logic
      const zoomInBtn = document.getElementById("zoom-in");
      const zoomOutBtn = document.getElementById("zoom-out");

      let activeCamera = camera;

      //Resetar a top camera ao default
      const resetTopCamBtn = document.getElementById("reset-topcam");

      const viewCheckboxes = document.querySelectorAll(
        '#sidebar input[type="checkbox"]'
      );

      // const bufferLevelSelect = document.getElementById("buffer-level");
      // let currentMaxBufferLevel = parseInt(bufferLevelSelect.value);

      // bufferLevelSelect.addEventListener("change", () => {
      //   currentMaxBufferLevel = parseInt(bufferLevelSelect.value);
      //   updateBufferLevels(currentMaxBufferLevel);
      // });

      //FUNCTION formatSpazioLabel(spazio) MADE MY GM
      function formatSpazioLabel(spazio) {
        const s = String(spazio).padStart(4, "0");
        return `${s.slice(0, 2)}.${s.slice(2)}`;
      }

      function updateBufferLevels(maxLevel) {
        if (!bufferGroup || bufferGroup.children.length === 0) return;

        const instancedMesh = bufferGroup.children.find(
          (child) => child.isInstancedMesh
        );
        if (!instancedMesh) return;

        const dummy = new THREE.Object3D();
        const count = instancedMesh.count;

        const tolerance = 0.1; // agrupar por (x, z)
        const yTolerance = 0.15; // agrupar níveis em Y

        const rackBuckets = [];

        // Agrupar buffers por posição XZ (mesma "coluna" de rack)
        for (let i = 0; i < count; i++) {
          instancedMesh.getMatrixAt(i, dummy.matrix);
          dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);

          const pos = dummy.position;
          let bucket = rackBuckets.find(
            (b) =>
              Math.abs(b.x - pos.x) < tolerance &&
              Math.abs(b.z - pos.z) < tolerance
          );

          if (!bucket) {
            bucket = { x: pos.x, z: pos.z, buffers: [] };
            rackBuckets.push(bucket);
          }

          bucket.buffers.push({ index: i, y: pos.y });
        }

        // Processar cada grupo de buffers empilhados por rack
        rackBuckets.forEach((bucket) => {
          const sorted = bucket.buffers.sort((a, b) => a.y - b.y);

          const levels = [];
          sorted.forEach((buf) => {
            let level = levels.find(
              (lvl) => Math.abs(lvl.y - buf.y) < yTolerance
            );
            if (!level) {
              level = { y: buf.y, buffers: [] };
              levels.push(level);
            }
            level.buffers.push(buf);
          });

          // Aplicar visibilidade com base no nível lógico
          levels.forEach((level, i) => {
            const show = i < maxLevel;

            level.buffers.forEach((buf) => {
              instancedMesh.getMatrixAt(buf.index, dummy.matrix);
              dummy.matrix.decompose(
                dummy.position,
                dummy.quaternion,
                dummy.scale
              );

              const originalScale = bufferOriginalScales[buf.index] || {
                x: 1,
                y: 1,
                z: 1,
              };

              dummy.scale.set(
                show ? originalScale.x : 0.0001,
                show ? originalScale.y : 0.0001,
                show ? originalScale.z : 0.0001
              );

              dummy.updateMatrix();
              instancedMesh.setMatrixAt(buf.index, dummy.matrix);
            });
          });
        });

        instancedMesh.instanceMatrix.needsUpdate = true;
      }

      viewCheckboxes.forEach((checkbox) => {
        checkbox.addEventListener("change", () => {
          const selected = Array.from(viewCheckboxes)
            .filter((cb) => cb.checked)
            .map((cb) => cb.value);

          rackGroup.visible = selected.includes("racks");
          corridorGroup.visible = selected.includes("corridors");
          bufferGroup.visible = selected.includes("buffers");
          spaceGroup.visible = selected.includes("spaces");
          dockGroup.visible = selected.includes("docks");
          stackGroup.visible = selected.includes("stacks");
          driveInGroup.visible = selected.includes("driveins");
        });
      });

      resetTopCamBtn.addEventListener("click", () => {
        if (activeCamera === topCamera) {
          topCamera.position.copy(rotatedPosition);
          topCamera.lookAt(initialTopCamTarget);
          // orbitControls.target.copy(initialTopCamTarget);
          employeeModel.position.copy(rotatedPosition);
        }
      });

      // Aumentar a illuminação Global ALTERAÇÃO GM

      zoomInBtn.addEventListener("click", () => {
        if (activeCamera === topCamera) {
          topCamera.fov = Math.max(10, topCamera.fov - 5); // Min FOV = more zoom
          topCamera.updateProjectionMatrix();
        }
      });

      zoomOutBtn.addEventListener("click", () => {
        if (activeCamera === topCamera) {
          topCamera.fov = Math.min(100, topCamera.fov + 5); // Max FOV = less zoom
          topCamera.updateProjectionMatrix();
        }
      });

      //topCamera.position.set(50, 100, 50);
      //topCamera.lookAt(50, 0, 50);

      // Luz ambiente suave
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); // luz geral
      scene.add(ambientLight);

      // Luz direcional clara
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
      directionalLight.position.set(50, 50, 50);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      const container = document.getElementById("container");

      const renderer = new THREE.WebGLRenderer({ antialias: true });

      //Corridor label render
      const labelRenderer = new CSS2DRenderer();

      const stats = new Stats();

      const GRAVITY = 30;
      const STEPS_PER_FRAME = 5;

      const worldOctree = new Octree();

      const playerCollider = new Capsule(
        new THREE.Vector3(50, 0.35, 50),
        new THREE.Vector3(50, 1, 50),
        0.35
      );

      const playerVelocity = new THREE.Vector3();
      const playerDirection = new THREE.Vector3();

      let playerOnFloor = false;
      let mouseTime = 0;

      const keyStates = {};

      const vector1 = new THREE.Vector3();
      const vector2 = new THREE.Vector3();
      const vector3 = new THREE.Vector3();

      let employeeModel;

      let rackGroup = new THREE.Group();
      let corridorGroup = new THREE.Group();
      let bufferGroup = new THREE.Group();
      let spaceGroup = new THREE.Group();
      let dockGroup = new THREE.Group();
      let stackGroup = new THREE.Group();
      let driveInGroup = new THREE.Group();

      scene.add(
        rackGroup,
        corridorGroup,
        bufferGroup,
        spaceGroup,
        dockGroup,
        stackGroup,
        driveInGroup
      );

      const tooltip = document.getElementById("tooltip");

      document.addEventListener("keydown", (event) => {
        keyStates[event.code] = true;

        if (event.code === "KeyT") {
          toggleCamera();
        }
      });

      document.addEventListener("keyup", (event) => {
        keyStates[event.code] = false;
      });

      container.addEventListener("mousedown", () => {
        if (
          activeCamera === camera &&
          document.pointerLockElement !== document.body
        ) {
          try {
            document.body.requestPointerLock();
            mouseTime = performance.now();
          } catch (e) {
            console.warn("Pointer lock request failed:", e);
          }
        }
      });

      document.body.addEventListener("mousemove", (event) => {
        if (
          document.pointerLockElement === document.body &&
          activeCamera === camera
        ) {
          mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
          if (document.pointerLockElement === document.body) {
            const sensitivity = 0.002;
            camera.rotation.y -= event.movementX * sensitivity;
            camera.rotation.x -= event.movementY * sensitivity;

            // Limita o olhar vertical (evita loop)
            const maxPitch = Math.PI / 2 - 0.1; // ligeiramente menos que 90°
            const minPitch = -Math.PI / 2 + 0.1; // ligeiramente mais que -90°
            camera.rotation.x = Math.max(
              minPitch,
              Math.min(maxPitch, camera.rotation.x)
            );
          }
        }
      });

      window.addEventListener("resize", onWindowResize);

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        topCamera.aspect = window.innerWidth / window.innerHeight;
        topCamera.updateProjectionMatrix();

        orthoCamera.left = (-ORTHO_SIZE * aspect) / 2;
        orthoCamera.right = (ORTHO_SIZE * aspect) / 2;
        orthoCamera.top = ORTHO_SIZE / 2;
        orthoCamera.bottom = -ORTHO_SIZE / 2;
        orthoCamera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function flipInstancedMeshX(instancedMesh, centerX) {
        const count = instancedMesh.count;
        const dummy = new THREE.Object3D();
        const flipped = new THREE.InstancedMesh(
          instancedMesh.geometry,
          instancedMesh.material,
          count
        );

        for (let i = 0; i < count; i++) {
          instancedMesh.getMatrixAt(i, dummy.matrix);
          dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);

          dummy.position.x = 2 * centerX - dummy.position.x;
          dummy.scale.x *= -1;

          dummy.updateMatrix();
          flipped.setMatrixAt(i, dummy.matrix);
        }

        flipped.instanceMatrix.needsUpdate = true;
        return flipped;
      }

      function flipWarehouseHorizontally() {
        const allGroups = [
          rackGroup,
          corridorGroup,
          bufferGroup,
          spaceGroup,
          dockGroup,
          stackGroup,
          driveInGroup,
        ];

        // Calcula limites do armazém
        const bounds = new THREE.Box3();
        allGroups.forEach((group) => {
          group.children.forEach((obj) => {
            bounds.expandByObject(obj);
          });
        });

        const minX = bounds.min.x;
        const maxX = bounds.max.x;
        const centerX = (minX + maxX) / 2;

        allGroups.forEach((group) => {
          const newChildren = [];

          for (let i = group.children.length - 1; i >= 0; i--) {
            const obj = group.children[i];

            if (obj.isInstancedMesh) {
              const flipped = flipInstancedMeshX(obj, centerX);
              group.remove(obj);
              obj.dispose?.();
              newChildren.push(flipped);
            } else {
              // Remove qualquer geometria duplicada (linhas de contorno por ex.)
              if (obj.userData?.skipFlip) continue;

              obj.position.x = 2 * centerX - obj.position.x;

              if (obj.geometry?.type === "PlaneGeometry") {
                obj.rotation.y += Math.PI;
              }

              obj.updateMatrix();
            }
          }

          // Adiciona novos InstancedMeshes
          newChildren.forEach((m) => group.add(m));
        });

        // Ajusta posição da câmera e do player
        camera.position.x = 2 * centerX - camera.position.x;
        camera.lookAt(centerX, camera.position.y, boundingBoxCenter.z);

        if (employeeModel) {
          employeeModel.position.x = 2 * centerX - employeeModel.position.x;
        }

        // Atualiza centro
        boundingBoxCenter.x = 2 * centerX - boundingBoxCenter.x;
      }
      function createSelectsLevels() {
        const container = document.getElementById("buffer-level-container");
        container.innerHTML = "";

        const tiposMap = new Map();

        EspacosAll.forEach((espaco) => {
          const tipo = (espaco.Spazio_tipo || "Desconhecido").trim();
          const nome = (espaco.Spazio_tipoD || tipo).trim();

          if (!tiposMap.has(tipo)) {
            tiposMap.set(tipo, { nome, objetos: [] });
          }
          tiposMap.get(tipo).objetos.push(espaco);
        });

        tiposMap.forEach(({ nome, objetos }, tipo) => {
          const espacos = objetos.map((obj) => {
            const base = parseFloat(obj.Spazio_coord_draw_b || 0);
            const altura = parseFloat(obj.Spazio_coord_alto || 0);
            const topo = base + altura;
            return { base, topo, altura };
          });

          const niveis = [];

          // Organizar espaços em níveis com lógica progressiva
          let restantes = [...espacos].filter((e) => e.altura > 0);

          while (restantes.length > 0) {
            // Encontrar o espaço com a menor base
            let menor = restantes.reduce((a, b) => (a.base < b.base ? a : b));
            let nivelAtual = [menor];

            // Definir topo do menor
            let topoMin = menor.topo;

            // Adicionar ao nível atual todos que tenham base < topoMin
            restantes = restantes.filter((e) => {
              if (e === menor) return false;
              if (e.base < topoMin) {
                nivelAtual.push(e);
                return false;
              }
              return true;
            });

            niveis.push(nivelAtual);
          }

          // Adicionar elementos de altura zero ao nível 1
          const zeroAltura = espacos.filter((e) => e.altura === 0);
          if (zeroAltura.length > 0) {
            if (!niveis[0]) niveis[0] = [];
            niveis[0].push(...zeroAltura);
          }

          // Debug: exibir info dos níveis
          console.log(
            `🧱 Tipo: ${nome} (${tipo}) - Total de níveis: ${niveis.length}`
          );
          niveis.forEach((nivel, i) => {
            const baseMin = Math.min(...nivel.map((e) => e.base));
            const topoMax = Math.max(...nivel.map((e) => e.topo));
            console.log(
              `  ➤ Nível ${i + 1}: base mínima = ${baseMin.toFixed(
                2
              )}, topo máxima = ${topoMax.toFixed(2)}, itens = ${nivel.length}`
            );
          });

          const maxNivel = niveis.length;

          // UI
          const row = document.createElement("div");
          row.style.display = "flex";
          row.style.alignItems = "center";
          row.style.gap = "8px";
          row.style.marginBottom = "6px";

          const label = document.createElement("label");
          label.textContent = nome;
          label.style.minWidth = "120px";

          const select = document.createElement("select");
          select.className = "buffer-select";
          select.dataset.tipo = tipo;

          for (let i = 1; i <= maxNivel; i++) {
            const option = document.createElement("option");
            option.value = i;
            option.textContent = i;
            if (i === maxNivel) option.selected = true;
            select.appendChild(option);
          }

          select.addEventListener("change", (e) => {
            const tipoSelecionado = e.target.dataset.tipo;
            const nivel = parseInt(e.target.value);
            updateBufferLevelsPorTipo(tipoSelecionado, nivel);
          });

          row.appendChild(label);
          row.appendChild(select);
          container.appendChild(row);
        });
      }

    function updateBufferLevelsPorTipo(tipo, nivelMax) {
  const allGroups = [
    rackGroup,
    corridorGroup,
    bufferGroup,
    spaceGroup,
    dockGroup,
    stackGroup,
    driveInGroup,
  ];

  const objetos = [];

  // Coletar objetos do tipo específico
  allGroups.forEach((group) => {
    group.children.forEach((child) => {
      if ((child.userData?.tipo || "").trim() === tipo) {
        objetos.push(child);
      }
    });
  });

  const espacos = objetos.map((obj) => {
    const box = new THREE.Box3().setFromObject(obj);
    const altura = box.max.y - box.min.y;
    const base = box.min.y;
    const topo = box.max.y;
    return { obj, base, topo, altura };
  });

  const niveis = [];

  let restantes = [...espacos].filter(e => e.altura > 0);

  while (restantes.length > 0) {
    const menor = restantes.reduce((a, b) => (a.base < b.base ? a : b));
    const nivelAtual = [menor];
    const topoMin = menor.topo;

    restantes = restantes.filter((e) => {
      if (e === menor) return false;
      if (e.base < topoMin) {
        nivelAtual.push(e);
        return false;
      }
      return true;
    });

    niveis.push(nivelAtual);
  }

  // Adicionar altura zero no nível 1
  const nivelZero = espacos.filter(e => e.altura === 0);
  if (nivelZero.length > 0) {
    if (!niveis[0]) niveis[0] = [];
    niveis[0].push(...nivelZero);
  }

  // Atualizar visibilidade
  niveis.forEach((nivel, i) => {
    const mostrar = i < nivelMax;
    nivel.forEach(({ obj }) => {
      obj.visible = mostrar;
    });
  });
}

      // Calculate the bounding box of all the racks and the center
      function calculateWallBoundingBox(racks) {
        const min = new THREE.Vector3(Infinity, Infinity, Infinity);
        const max = new THREE.Vector3(-Infinity, -Infinity, -Infinity);

        racks.forEach((rack) => {
          const position = new THREE.Vector3(
            rack.Spazio_coord_draw_a / 100,
            rack.Spazio_coord_draw_b / 100,
            rack.Spazio_coord_draw_c / 100
          );

          min.min(position);
          max.max(position);
        });

        const center = new THREE.Vector3(
          (min.x + max.x) / 2,
          (min.y + max.y) / 2,
          (min.z + max.z) / 2
        );

        return { min, max, center };
      }

      function createWall(position, size) {
        const geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
        const material = new THREE.MeshLambertMaterial({ color: 0xd1d1d1 });
        const wall = new THREE.Mesh(geometry, material);
        wall.position.copy(position);
        wall.castShadow = true;
        wall.receiveShadow = true;
        scene.add(wall);
        worldOctree.fromGraphNode(wall);
      }
      function createWarehouseAreaFromComponentsAll() {
        const allMeshes = [
          ...classeEspExecMeshes,
          ...classeEspArmMeshes,
          ...classeDivEspacosMeshes,
          ...classeZonAnomalasMeshes,
          ...classeEspacoDistrMeshes,
          ...classeTransportesMeshes,
          ...classeTransicaoMeshes,
          ...classePilhaMeshes,
          ...classeCaisTemporarioMeshes,
        ];

        if (allMeshes.length === 0) return;

        // Expande o bounding box com todos os objetos renderizados
        const bounds = new THREE.Box3();
        allMeshes.forEach((mesh) => bounds.expandByObject(mesh));

        const min = bounds.min.clone(); // ponto mínimo (x, y, z)
        const max = bounds.max.clone(); // ponto máximo (x, y, z)

        const wallHeight = 5;
        const wallThickness = 0.05;
        const wallMargin = 10.0; // Margem leve para que tudo caiba dentro com folga

        // Ajusta min/max para incluir margem
        const adjustedMin = min.clone().subScalar(wallMargin);
        const adjustedMax = max.clone().addScalar(wallMargin);

        const width = adjustedMax.x - adjustedMin.x;
        const depth = adjustedMax.z - adjustedMin.z;

        const centerX = (adjustedMin.x + adjustedMax.x) / 2;
        const centerZ = (adjustedMin.z + adjustedMax.z) / 2;

        // Define o centro do armazém para efeitos de teleport ou câmera
        boundingBoxCenter.set(centerX, 0, centerZ);

        // Cria as 4 paredes
        createWall(
          new THREE.Vector3(centerX, wallHeight / 2, adjustedMin.z),
          new THREE.Vector3(width + wallThickness, wallHeight, wallThickness)
        );
        createWall(
          new THREE.Vector3(centerX, wallHeight / 2, adjustedMax.z),
          new THREE.Vector3(width + wallThickness, wallHeight, wallThickness)
        );
        createWall(
          new THREE.Vector3(adjustedMin.x, wallHeight / 2, centerZ),
          new THREE.Vector3(wallThickness, wallHeight, depth + wallThickness)
        );
        createWall(
          new THREE.Vector3(adjustedMax.x, wallHeight / 2, centerZ),
          new THREE.Vector3(wallThickness, wallHeight, depth + wallThickness)
        );

        // Cria o chão
        const floorGeometry = new THREE.PlaneGeometry(width, depth);
        const floorMaterial = new THREE.MeshLambertMaterial({
          color: 0x30384f,
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(centerX, 0, centerZ);
        floor.receiveShadow = true;
        scene.add(floor);
        worldOctree.fromGraphNode(floor);
      }

      // F2 change parameter name in all document
      // Create walls around the bounding box with a margin

      // Calcula se algum vetor interseta com um bounding box
      function playerCollisions() {
        const result = worldOctree.capsuleIntersect(playerCollider);
        playerOnFloor = false;

        if (result) {
          playerOnFloor = result.normal.y > 0;

          if (!playerOnFloor) {
            playerVelocity.addScaledVector(
              result.normal,
              -result.normal.dot(playerVelocity)
            );
          }

          playerCollider.translate(result.normal.multiplyScalar(result.depth));
        }
      }

      // Atualizar o player a cada frame (colisões, velocidade)
      function updatePlayer(deltaTime) {
        let damping = Math.exp(-4 * deltaTime) - 1;

        if (!playerOnFloor) {
          playerVelocity.y -= GRAVITY * deltaTime;
          damping *= 0.1;
        }

        playerVelocity.addScaledVector(playerVelocity, damping);

        const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
        playerCollider.translate(deltaPosition);

        // colisões
        playerCollisions();

        camera.position.copy(playerCollider.end);
        camera.position.copy(playerCollider.end);

        // Evita que a câmera continue a olhar para baixo após colisões
        if (!document.pointerLockElement) {
          camera.rotation.set(0, 0, 0); // só se não estiver no modo pointerlock
        }

        // Clamp player position inside warehouse bounds
      }

      function getForwardVector() {
        camera.getWorldDirection(playerDirection);
        playerDirection.y = 0;
        playerDirection.normalize();
        return playerDirection;
      }

      function getSideVector() {
        camera.getWorldDirection(playerDirection);
        playerDirection.y = 0;
        playerDirection.normalize();
        playerDirection.cross(camera.up);
        return playerDirection;
      }

      // Ativar movimentos com as teclas
      function handleControls(deltaTime) {
        const speedDelta = deltaTime * (playerOnFloor ? 25 : 8);

        if (activeCamera === camera) {
          if (keyStates["KeyW"]) {
            playerVelocity.add(getForwardVector().multiplyScalar(speedDelta));
          }

          if (keyStates["KeyS"]) {
            playerVelocity.add(getForwardVector().multiplyScalar(-speedDelta));
          }

          if (keyStates["KeyA"]) {
            playerVelocity.add(getSideVector().multiplyScalar(-speedDelta));
          }

          if (keyStates["KeyD"]) {
            playerVelocity.add(getSideVector().multiplyScalar(speedDelta));
          }

          if (playerOnFloor) {
            if (keyStates["Space"]) {
              playerVelocity.y = 15;
            }
          }
        }
      }

      // wtv
      const helper = new OctreeHelper(worldOctree);
      helper.visible = false;
      scene.add(helper);

      // wtv
      // const gui = new GUI({ width: 200 });
      // gui.add({ debug: false }, "debug").onChange(function (value) {
      //   helper.visible = value;
      // });

      // Se o personagem foge do mapa ele volta
      function teleportPlayerIfOob() {
        if (camera.position.y <= -25) {
          playerCollider.start.set(
            boundingBoxCenter.x,
            boundingBoxCenter.y + 0.35,
            boundingBoxCenter.z
          );
          playerCollider.end.set(
            boundingBoxCenter.x,
            boundingBoxCenter.y + 1,
            boundingBoxCenter.z
          );
          playerCollider.radius = 0.35;
          camera.position.copy(playerCollider.end);
          camera.rotation.set(0, Math.PI, 0); // reinicia com rotação para frente
          playerVelocity.set(0, 0, 0); // zera velocidade também
        }
      }

      // Alterar entre camaras
      function toggleCamera() {
        activeCamera = activeCamera === camera ? topCamera : camera;

        if (employeeModel) {
          employeeModel.position.copy(playerCollider.end);
          employeeModel.visible = activeCamera === topCamera;
        }

        if (activeCamera === camera) {
          document.body.requestPointerLock();
        } else {
          document.exitPointerLock();
        }
        orbitControls.target.copy(playerCollider.end);
      }

      const orbitControls = new OrbitControls(topCamera, renderer.domElement);
      //orbitControls.target.set(45, 10, 79.49);
      orbitControls.screenSpacePanning = true;
      orbitControls.minDistance = 1;
      orbitControls.maxDistance = 10000;
      orbitControls.maxPolarAngle = Math.PI / 2;
      orbitControls.enablePan = true;
      orbitControls.enableDamping = true;
      orbitControls.enabled = true;
      orbitControls.dampingFactor = 0.05;

      // Atualização da cena
      function animate() {
        const deltaTime = Math.min(0.05, clock.getDelta()) / STEPS_PER_FRAME;

        for (let i = 0; i < STEPS_PER_FRAME; i++) {
          handleControls(deltaTime);
          updatePlayer(deltaTime);
          teleportPlayerIfOob();
        }

        if (employeeModel) {
          // Toggle visibility of employee based on active camera
          employeeModel.visible = true;
          employeeModel.position.copy(playerCollider.end);
        }
        if (activeCamera === topCamera) {
          moveTopCamera(deltaTime * 60);
          orbitControls.update();
        }

        if (activeCamera === camera) {
          const maxPitch = Math.PI / 2 - 0.1;
          const minPitch = -Math.PI / 2 + 0.1;
          camera.rotation.x = Math.max(
            minPitch,
            Math.min(maxPitch, camera.rotation.x)
          );
        }

        outlinesArray.forEach(({ outline, position }) => {
          const dist = activeCamera.position.distanceTo(position);
          outline.visible = dist < 150; // Podes ajustar o valor de 40
        });
        renderer.render(scene, activeCamera);
        labelRenderer.render(scene, activeCamera);

        stats.update();
      }
      // NEW DYNAMIC FUNCTIONS TO DRAW SPACES GM
      // Spazio_classe === "02"
      async function createDistributionFromJSON(distribuicoes) {
        distribuicoes.forEach((item) => {
          const width = parseFloat(item.Spazio_coord_largo) / 100;
          const height = parseFloat(item.Spazio_coord_alto) / 100;
          const depth = parseFloat(item.Spazio_coord_fondo) / 100;

          const x = parseFloat(item.Spazio_coord_draw_a) / 100;
          const y = parseFloat(item.Spazio_coord_draw_b) / 100;
          const z = parseFloat(item.Spazio_coord_draw_c) / 100;

          //Geometry and Material resources
          const getRandomColor = () => Math.floor(Math.random() * 0xffffff);
          const hexColor =
            item.Colore && item.Colore !== "null"
              ? parseInt(item.Colore.replace("#", ""), 16)
              : getRandomColor();

          const geometry = new THREE.BoxGeometry(width, height, depth);
          const material = new THREE.MeshStandardMaterial({ hexColor });

          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.set(x, y + height / 2, z);

          scene.add(mesh);
        });
      }
      //Spazio_classe === "03"
      async function createDockFromJSON(docks) {
        docks.forEach((dock) => {
          const x = parseFloat(dock.Spazio_coord_draw_a) / 100;
          const y = parseFloat(dock.Spazio_coord_draw_b) / 100;
          const z = parseFloat(dock.Spazio_coord_draw_c) / 100;

          let width = parseFloat(dock.Spazio_coord_largo) / 100;
          const height = parseFloat(dock.Spazio_coord_alto) / 100;
          let depth = parseFloat(dock.Spazio_coord_fondo) / 100;

          const orientation = String(dock.Spazio_orientamento).trim();
          if (orientation === "1") {
            [width, depth] = [depth, width];
          }

          // Cor do JSON ou azul padrao
          let hexColor;
          if (dock.Colore && dock.Colore !== "null") {
            try {
              hexColor = parseInt(dock.Colore.replace("#", ""), 16);
            } catch {
              hexColor = 0x73a7f5;
            }
          } else {
            hexColor = 0x73a7f5;
          }

          const geometry = new THREE.BoxGeometry(width, height, depth);
          const material = new THREE.MeshBasicMaterial({
            color: hexColor,
            transparent: true,
            opacity: 0.9,
            depthWrite: false,
          });

          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.set(x + width / 2, y + height / 2, z + depth / 2);
          dockGroup.add(mesh);

          // Contorno branco
          const edges = new THREE.EdgesGeometry(geometry);
          const line = new THREE.LineSegments(
            edges,
            new THREE.LineBasicMaterial({ color: 0xffffff })
          );
          line.position.copy(mesh.position);

          classeCaisMeshes.push(mesh);
          dockGroup.add(line);
        });
        console.log(
          `Cais desenhados (usando posição e altura do JSON): ${docks.length}`
        );
      }
      //Spazio_classe === "06"
      async function createWarahouseSpacesFromJSON(warehouseArray) {
        const opacity = 0.95;
        const shrinkFactor = 0.65;

        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const dummy = new THREE.Object3D();

        const instancedMeshesByColor = {};

        warehouseArray.forEach((item, i) => {
          const x = parseFloat(item.Spazio_coord_draw_a) / 100;
          const y = parseFloat(item.Spazio_coord_draw_b) / 100;
          const z = parseFloat(item.Spazio_coord_draw_c) / 100;

          let width = parseFloat(item.Spazio_coord_largo || 80) / 100;
          const height = parseFloat(item.Spazio_coord_alto || 180) / 100;
          let depth = parseFloat(item.Spazio_coord_fondo || 120) / 100;

          const orientation = String(item.Spazio_orientamento).trim();
          if (orientation === "1") {
            [width, depth] = [depth, width];
          }

          const scaleX = width * shrinkFactor;
          const scaleY = height * shrinkFactor;
          const scaleZ = depth * shrinkFactor;

          let hexColor;
          if (item.Colore && item.Colore !== "null") {
            try {
              hexColor = parseInt(item.Colore.replace("#", ""), 16);
            } catch {
              hexColor = Math.floor(Math.random() * 0xffffff);
            }
          } else {
            hexColor = Math.floor(Math.random() * 0xffffff);
          }

          if (!instancedMeshesByColor[hexColor]) {
            const material = new THREE.MeshBasicMaterial({
              color: hexColor,
              transparent: true,
              opacity: opacity,
            });
            instancedMeshesByColor[hexColor] = {
              mesh: new THREE.InstancedMesh(geometry, material, 0),
              count: 0,
              transforms: [],
            };
          }

          const meshData = instancedMeshesByColor[hexColor];
          dummy.position.set(x + width / 2, y + height / 2, z + depth / 2);
          dummy.scale.set(scaleX, scaleY, scaleZ);
          dummy.updateMatrix();

          meshData.transforms.push(dummy.matrix.clone());
          meshData.count++;
        });

        // Adiciona todas as instanced meshes ao grupo final
        for (const colorKey in instancedMeshesByColor) {
          const { mesh, count, transforms } = instancedMeshesByColor[colorKey];
          mesh.count = count;
          transforms.forEach((matrix, idx) => mesh.setMatrixAt(idx, matrix));
          mesh.instanceMatrix.needsUpdate = true;
          bufferGroup.add(mesh);
        }
        console.log(
          `Espaços de armazenamento desenhados: ${warehouseArray.length}`
        );
      }

      // END NEW DYNAMIC FUNCTIONS TO DRAW SPACES
      async function createRacksFromJSON(racks) {
        const shrinkFactor = 0.95;
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const dummy = new THREE.Object3D();
        const outlineGroup = new THREE.Group();
        const defaultColor = new THREE.Color("#5865f2");
        const count = racks.length;

        const material = new THREE.MeshBasicMaterial({
          color: defaultColor,
          transparent: true,
          opacity: 0.3,
          depthWrite: false,
        });

        const instancedMesh = new THREE.InstancedMesh(
          geometry,
          material,
          count
        );
        instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

        const outlineGeometry = new THREE.EdgesGeometry(geometry);
        const outlineMaterial = new THREE.LineBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 1,
        });

        const color = new THREE.Color();
        const colorArray = new Float32Array(count * 3); // RGB por instância
        instancedMesh.userData.tipo = "rack";

        racks.forEach((rack, i) => {
          const x = parseFloat(rack.Spazio_coord_draw_a || 0) / 100;
          const y = parseFloat(rack.Spazio_coord_draw_b || 0) / 100;
          const z = parseFloat(rack.Spazio_coord_draw_c || 0) / 100;

          let width = parseFloat(rack.Spazio_coord_largo || 120) / 100;
          const height = parseFloat(rack.Spazio_coord_alto || 925) / 100;
          let depth = parseFloat(rack.Spazio_coord_fondo || 320) / 100;

          const orientation = String(rack.Spazio_orientamento || "").trim();
          if (orientation === "1") [width, depth] = [depth, width];

          dummy.position.set(x + width / 2, y + height / 2, z + depth / 2);
          dummy.scale.set(
            width * shrinkFactor,
            height * shrinkFactor,
            depth * shrinkFactor
          );
          dummy.updateMatrix();

          instancedMesh.setMatrixAt(i, dummy.matrix);
          instancedMesh.userData.tipo = rack.Spazio_tipo;
          instancedMesh.userData.tipoD = rack.Spazio_tipoD;
          instancedMesh.userData.spazio_disp = rack.Spazio_disponibile;

          // Cria contorno invisível
          const outline = new THREE.LineSegments(
            outlineGeometry,
            outlineMaterial.clone()
          );
          outline.applyMatrix4(dummy.matrix);
          outline.visible = false;
          outline.userData.tipo = rack.Spazio_tipo;
          outlineGroup.add(outline);

          // Armazena para hover ou seleção futura
          outlinesArray.push({
            outline,
            position: dummy.position.clone(),
          });

          let colorString = rack.ColoreD;
          try {
            if (colorString && typeof colorString === "string") {
              color.set(colorString.toLowerCase());
            } else {
              color.copy(defaultColor);
            }
          } catch (err) {
            console.warn(`Cor inválida no rack[${i}]:`, rack.ColoreD);
            color.copy(defaultColor);
          }

          color.toArray(colorArray, i * 3);
        });

        instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(
          colorArray,
          3
        );
        instancedMesh.instanceMatrix.needsUpdate = true;
        rackGroup.add(instancedMesh);

        outlineGroup.children.forEach((child) => {
          rackGroup.add(child);
        });
        classeDivEspacosMeshes.push(instancedMesh);

        console.log(`Racks desenhados: ${count}`);
      }

      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      let hoveredRack = null;

      function isFullyVisible(obj) {
        if (!obj.visible) return false;
        let parent = obj.parent;
        while (parent) {
          if (!parent.visible) return false;
          parent = parent.parent;
        }
        return true;
      }
      function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, activeCamera);

        // Você pode incluir mais objetos instanciados aqui se quiser
        const instancedTargets = [
          ...classeDivEspacosMeshes.filter((m) => m.isInstancedMesh),
        ];

        const intersects = raycaster.intersectObjects(instancedTargets, true);

        if (intersects.length > 0) {
          const intersect = intersects[0];

          const mesh = intersect.object;
          const instanceId = intersect.instanceId;

          if (mesh && mesh.isInstancedMesh && typeof instanceId === "number") {
            // Se mudou de instância
            if (
              hoveredInstance &&
              (hoveredInstance.mesh !== mesh ||
                hoveredInstance.id !== instanceId)
            ) {
              // Restaura cor anterior

              hoveredInstance = null;
            }

            if (!hoveredInstance) {
              hoveredInstance = {
                mesh,
                id: instanceId,
              };
            }

            // Tooltip
            const pos = intersect.point;
            tooltip.style.left = event.clientX + 10 + "px";
            tooltip.style.top = event.clientY + 10 + "px";
            tooltip.innerHTML = `<strong>${
              mesh.userData.tipoD
            }</strong><br>ID: ${instanceId}<br>
${
  mesh.userData.spazio_disp == "0" ? "Espaço Indisponível" : "Espaço Disponível"
}`;
            tooltip.style.display = "block";
            document.body.style.cursor = "pointer";
            return;
          }
        }

        // Nenhum hover válido
        if (hoveredInstance) {
          hoveredInstance = null;
        }

        tooltip.style.display = "none";
        document.body.style.cursor = "default";
      }

      window.addEventListener("mousemove", onMouseMove);

      const topCamMoveSpeed = 5;

      function moveTopCamera(deltaTime) {
        const speed = topCamMoveSpeed * deltaTime;

        const forward = new THREE.Vector3();
        topCamera.getWorldDirection(forward);
        forward.y = 0;
        forward.normalize();

        const right = new THREE.Vector3();
        right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

        const move = new THREE.Vector3();

        if (keyStates["KeyW"]) move.add(forward); // Forward
        if (keyStates["KeyS"]) move.sub(forward); // Backward
        if (keyStates["KeyD"]) move.add(right); // Right
        if (keyStates["KeyA"]) move.sub(right); // Left

        move.normalize().multiplyScalar(speed);
        topCamera.position.add(move);
        // After moving camera

        employeeModel.position.copy(topCamera.position);

        orbitControls.target.add(move);
      }
      // cria um cubo que representa a posição do empregado
      function createEmployee() {
        const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.6); // Adjust size as needed
        const material = new THREE.MeshLambertMaterial({ color: 0xff0000 }); // Adjust color and material as needed
        employeeModel = new THREE.Mesh(geometry, material);
        employeeModel.position.copy(playerCollider.end); // Position the cube where the employee model would be
        employeeModel.visible = false; // Initially hide the cube
        scene.add(employeeModel);
      }

      // Function to create spaces from JSON data using InstancedMesh ISTO É O PICKING BASICAMENTE MAS A AVERIGUAR
      function createSpacesFromJSON() {
        const spaceColor = 0x00ff00;
        const spaceOpacity = 0.95;
        const shrinkFactor = 0.65;

        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshBasicMaterial({
          color: spaceColor,
          transparent: true,
          opacity: spaceOpacity,
          depthWrite: true,
          side: THREE.DoubleSide,
        });

        const instancedMesh = new THREE.InstancedMesh(
          geometry,
          material,
          spaces.length
        );

        const dummy = new THREE.Object3D();

        spaces.forEach((space, i) => {
          const x = parseFloat(space.Spazio_coord_draw_a) / 100;
          const y = parseFloat(space.Spazio_coord_draw_b) / 100;
          const z = parseFloat(space.Spazio_coord_draw_c) / 100;

          let width = parseFloat(space.Spazio_coord_largo || 80) / 100;
          const height = parseFloat(space.Spazio_coord_alto || 180) / 100;
          let depth = parseFloat(space.Spazio_coord_fondo || 120) / 100;

          const orientation = String(space.Spazio_orientamento).trim();
          if (orientation === "1") {
            const temp = width;
            width = depth;
            depth = temp;
          }

          const px = x + width / 2;
          const py = y + height / 2;
          const pz = z + depth / 2;

          dummy.position.set(px, py, pz);
          dummy.scale.set(
            width * shrinkFactor,
            height * shrinkFactor,
            depth * shrinkFactor
          );

          dummy.updateMatrix();
          instancedMesh.setMatrixAt(i, dummy.matrix);
        });

        spaceGroup.add(instancedMesh);
        console.log(`Spaces created: ${spaces.length}`);
      }

      function addLabelForSingleComponent(component, type = "", name = "") {
        if (!component || !component.Spazio) return;

        const label = formatSpazioLabel(component.Spazio);

        const x = parseFloat(component.Spazio_coord_draw_a) / 100;
        const y = parseFloat(component.Spazio_coord_draw_b) / 100;
        const z = parseFloat(component.Spazio_coord_draw_c) / 100;

        const width = parseFloat(component.Spazio_coord_largo || 0) / 100;
        const height = parseFloat(component.Spazio_coord_alto || 0) / 100;
        const depth = parseFloat(component.Spazio_coord_fondo || 0) / 100;

        const labelDiv = document.createElement("div");
        labelDiv.className = `label toggle-label toggle-label-${type}`;
        labelDiv.textContent = label;
        labelDiv.style.color = "white";
        labelDiv.style.fontSize = "12px";
        labelDiv.style.fontWeight = "bold";
        labelDiv.style.pointerEvents = "none";
        labelDiv.style.backgroundColor = "transparent";
        labelDiv.style.padding = "2px 4px";
        labelDiv.style.borderRadius = "4px";

        const labelObj = new CSS2DObject(labelDiv);
        labelObj.position.set(0, 0.05, 0);
        labelObj.rotation.x = -Math.PI / 2;

        const dummy = new THREE.Object3D();

        const isCorridor = corridorGroup.children.some((child) => {
          if (child.isInstancedMesh) {
            return child.userData?.tipo === component.Spazio_tipo;
          }
          return false;
        });

        if (isCorridor) {
          dummy.position.set(x + width / 2, 0, z + depth / 2);
        } else {
          dummy.position.set(x + width / 2, y + height, z + depth / 2);
        }

        dummy.add(labelObj);
        scene.add(dummy);
      }

      //Create buffers from the JSON -> GM ALTERAÇÃO FUNÇAO CREATEBUFFERFROMJSON
      /* function createBufferFromJSON(bufferArray) {
        const bufferColor = 0xd48c8c;
        const bufferOpacity = 0.95;
        const shrinkFactor = 0.65;

        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshBasicMaterial({
          color: bufferColor,
          transparent: true,
          opacity: bufferOpacity,
        });

        const count = bufferArray.length;
        const instancedMesh = new THREE.InstancedMesh(
          geometry,
          material,
          count
        );
        const dummy = new THREE.Object3D();

        bufferArray.forEach((item, i) => {
          const x = parseFloat(item.Spazio_coord_draw_a) / 100;
          const y = parseFloat(item.Spazio_coord_draw_b) / 100;
          const z = parseFloat(item.Spazio_coord_draw_c) / 100;

          let width = parseFloat(item.Spazio_coord_largo || 80) / 100;
          const height = parseFloat(item.Spazio_coord_alto || 180) / 100;
          let depth = parseFloat(item.Spazio_coord_fondo || 120) / 100;

          const orientation = String(item.Spazio_orientamento).trim();
          if (orientation === "1") {
            [width, depth] = [depth, width];
          }

          const scaleX = width * shrinkFactor;
          const scaleY = height * shrinkFactor;
          const scaleZ = depth * shrinkFactor;

          dummy.position.set(x + width / 2, y + height / 2, z + depth / 2);
          dummy.scale.set(scaleX, scaleY, scaleZ);
          dummy.updateMatrix();
          instancedMesh.setMatrixAt(i, dummy.matrix);

          // ✅ Salva a escala real
          bufferOriginalScales[i] = { x: scaleX, y: scaleY, z: scaleZ };
        });

        bufferGroup.add(instancedMesh);
        bufferInstancedMesh = instancedMesh;

        console.log(`Buffers desenhados: ${count}`);
      } */

      function mirrorDataXCoordinates(data) {
        const centerX = getLayoutCenterX(data);

        const mirrorArray = (arr) => {
          arr?.forEach((item) => {
            let x = parseFloat(item.Spazio_coord_draw_a || "0");
            let width = parseFloat(item.Spazio_coord_largo || "0");
            let depth = parseFloat(item.Spazio_coord_fondo || "0");

            const orientation = String(item.Spazio_orientamento || "").trim();

            // Flip width/depth if orientation is along X
            if (orientation === "1") {
              [width, depth] = [depth, width];
            }

            const objectCenterX = x + width / 2;
            const mirroredCenterX = 2 * centerX - objectCenterX;

            item.Spazio_coord_draw_a = (mirroredCenterX - width / 2).toFixed(2);
          });
        };

        mirrorArray(data.Racks);
        mirrorArray(data.Spaces);
        mirrorArray(data.Buffer);
        mirrorArray(data.Cais);
        mirrorArray(data.Pilhas);
        mirrorArray(data.DriveIn);
        mirrorArray(data.Corridor);
      }

      function getLayoutCenterX(data) {
        const allX = [
          ...data.classeDivEspacos,
          ...data.classeExec,
          ...data.classeDocks,
          ...data.classeStacks,
          ...data.classeTransporte,
          ...data.classeArmaz,
          ...data.classeDist,
        ]

          .map((item) => parseFloat(item.Spazio_coord_draw_a))
          .filter((x) => !isNaN(x));

        const minX = Math.min(...allX);
        const maxX = Math.max(...allX);
        return (minX + maxX) / 2;
      }

      function addFlatLabelToObject(object, text, type = "") {
        const labelDiv = document.createElement("div");
        labelDiv.className = `label toggle-label toggle-label-${type}`;
        labelDiv.textContent = text;
        labelDiv.style.color = "white";
        labelDiv.style.fontSize = "12px";
        labelDiv.style.fontWeight = "bold";
        labelDiv.style.pointerEvents = "none";
        labelDiv.style.backgroundColor = "transparent";
        labelDiv.style.padding = "2px 4px";
        labelDiv.style.borderRadius = "4px";

        const label = new CSS2DObject(labelDiv);
        label.position.set(0, 0.05, 0);
        label.rotation.x = -Math.PI / 2;

        object.add(label);
      }

      function addFlatLabelsToWarehouse() {
        // racks?.forEach((r) => addLabelForSingleComponent(r, "racks", ""));
        // docks?.forEach((d) => addLabelForSingleComponent(d, "docks", ""));
        // stacks?.forEach((s) => addLabelForSingleComponent(s, "stacks", ""));
        // driveIns?.forEach((d) => addLabelForSingleComponent(d, "driveins", ""));
        // buffers?.forEach((b) =>
        //   addLabelForSingleComponent(b, "buffers", "buffer")
        // );
        corredor?.forEach((c) => addLabelForSingleComponent(c));
        // spaces?.forEach((s) =>
        //   addLabelForSingleComponent(s, "spaces", "picking")
        // );
      }

      function gerarMenuToggleLabels(...listas) {
        const labelToggleList = document.getElementById("label-toggle-list");
        labelToggleList.innerHTML = ""; // Limpa entradas anteriores

        const tiposMap = new Map(); // Para evitar duplicados

        listas.forEach((lista) => {
          lista.forEach((item) => {
            const tipo = item.Spazio_tipo?.trim() || "Desconhecido";
            const label = item.Spazio_tipoD?.trim() || tipo;

            if (!tiposMap.has(tipo)) {
              tiposMap.set(tipo, label);
            }
          });
        });

        for (const [tipo, label] of tiposMap.entries()) {
          const li = document.createElement("li");

          const input = document.createElement("input");
          input.type = "checkbox";
          input.className = "label-toggle";
          input.value = tipo;
          input.id = `toggle-label-${tipo}`;

          const inputLabel = document.createElement("label");
          inputLabel.setAttribute("for", input.id);
          inputLabel.appendChild(input);
          inputLabel.append(` ${label}`);

          li.appendChild(inputLabel);
          labelToggleList.appendChild(li);
        }
      }

      async function extractDataFromJSON(data) {
        // Filtros por classe
        const classeDivEspacos = data.filter((d) => d.Spazio_classe === "04"); // Divisões Espaços
        const classeExec = data.filter((d) => d.Spazio_classe === "01"); // Execução
        const classeDocks = data.filter((d) => d.Spazio_classe === "03"); // Cais
        const classeStacks = data.filter((d) => d.Spazio_classe === "09"); // Pilha
        const classeTransporte = data.filter((d) => d.Spazio_classe === "07"); // Transportes
        const classeArmaz = data.filter((d) => d.Spazio_classe === "02"); // Armazenamento DONE
        const classeDist = data.filter((d) => d.Spazio_classe === "06"); // Estações de Loja DONE
        // Bounding box com base nas racks
        const relevantWalls = classeDivEspacos.filter(
          (e) => parseFloat(e.Spazio_coord_alto) !== 0
        );

        wallBoundingBoxCoords = calculateWallBoundingBox(relevantWalls);
        boundingBoxCenter.copy(wallBoundingBoxCoords.center);

        playerCollider.start.set(
          boundingBoxCenter.x,
          0.35,
          boundingBoxCenter.z
        );
        playerCollider.end.set(boundingBoxCenter.x, 1, boundingBoxCenter.z);

        camera.position.copy(playerCollider.end);
        camera.rotation.set(0, Math.PI, 0);

        orbitControls.target.set(boundingBoxCenter.x, 50, boundingBoxCenter.z);

        // Chamada das funções com os dados corretos

        // await createDistributionFromJSON(classeDist); // <- GM
        // await createWarahouseSpacesFromJSON(classeArmaz); // GM
        // await createDockFromJSON(classeDocks); //GM
        await processDivSpacesClass(classeDivEspacos);
        createWarehouseAreaFromComponentsAll();
        // addFlatLabelsToWarehouse();
        gerarMenuToggleLabels(
          classeDivEspacos,
          classeExec,
          classeDocks,
          classeStacks,
          classeTransporte,
          classeArmaz,
          classeDist
        );
        applyInitialLabelVisibilityFromMenu();

        EspacosAll = [
          ...classeDivEspacos,
          ...classeExec,
          ...classeDocks,
          ...classeStacks,
          ...classeTransporte,
          ...classeArmaz,
          ...classeDist,
        ];

        const EspacosPorTipo = {};

        EspacosAll.forEach((item) => {
          const tipo = item.Spazio_tipoD?.trim() || "Desconhecido";

          if (!EspacosPorTipo[tipo]) {
            EspacosPorTipo[tipo] = [];
          }

          EspacosPorTipo[tipo].push(item);
        });

        createSelectsLevels();

        document.querySelectorAll(".label-toggle").forEach((checkbox) => {
          checkbox.addEventListener("change", (e) => {
            const type = e.target.value;
            const isVisible = e.target.checked;

            const labelsExist = document.querySelector(`.toggle-label-${type}`);
            if (isVisible && !labelsExist) {
              // Cria as labels apenas se ainda não existem
              EspacosAll.forEach((item) => {
                const itemTipo = (item.Spazio_tipo || "").trim();
                if (itemTipo === type) {
                  addLabelForSingleComponent(item, type, ""); // Usa o tipo como classe
                }
              });
            }

            // Atualiza visibilidade das labels desse tipo
            labelRenderer.domElement
              .querySelectorAll(`.toggle-label-${type}`)
              .forEach((el) => {
                el.style.visibility = isVisible ? "visible" : "hidden";
              });
          });
        });

        createEmployee();
        const deltaTime = Math.min(0.05, clock.getDelta()) / STEPS_PER_FRAME;
        return {
          classeDivEspacos,
          classeExec,
          classeDocks,
          classeStacks,
          classeTransporte,
          classeArmaz,
          classeDist,
        };
      }

      function trocarCoordenadasBC(array) {
        array.forEach((item) => {
          const temp = item.Spazio_coord_draw_b;
          item.Spazio_coord_draw_b = item.Spazio_coord_draw_c;
          item.Spazio_coord_draw_c = temp;
        });
      }

      let comps;
      function processDivSpacesClass(componentes) {
        const tiposMap = {};

        // Agrupar por tipo de espaço
        componentes.forEach((item) => {
          const tipo = item.Spazio_tipo || "Desconhecido";
          if (!tiposMap[tipo]) {
            tiposMap[tipo] = [];
          }
          tiposMap[tipo].push(item);
        });

        // Painel de controle
        // Painel de controle dentro da sidebar
        let controlBox = document.getElementById("grupo-controls");
        if (!controlBox) {
          controlBox = document.createElement("div");
          controlBox.id = "grupo-controls";
          controlBox.classList.add("dropdown-group"); // usa classe já estilizada no CSS

          const sidebar = document.getElementById("sidebar");
          if (sidebar) {
            sidebar.appendChild(controlBox);
          } else {
            console.warn(
              "Sidebar não encontrada. controlBox será adicionado ao body."
            );
            document.body.appendChild(controlBox); // fallback
          }
        }
        controlBox.innerHTML = `
 
              <span   style="display: flex; align-items: center; gap: 6px; font-weight:bold">
              <i class="ph ph-layout"></i>
              <span id="toggle-tipos" >ALTURA DE ESPAÇOS</span>
            </span>
  <ul id="grupo-lista-tipos" style="padding-left: 10px; margin-top: 6px;"></ul>
`;
        const toggleHeader = controlBox.querySelector("#toggle-tipos");
        const tipoLista = controlBox.querySelector("#grupo-lista-tipos");

        toggleHeader.addEventListener("click", () => {
          const isVisible = tipoLista.style.display !== "none";
          tipoLista.style.display = isVisible ? "none" : "block";
        });

        // Processar cada grupo

        for (const tipo in tiposMap) {
          const grupo = tiposMap[tipo];
          const varName = `tipo${tipo}Meshes`;

          // Criar visual inicial baseado na altura do 1º item
          const temAltura = grupo.some((item) => {
            if (!item || item.Spazio_coord_alto == null) return false;
            return parseFloat(item.Spazio_coord_alto) > 0.001;
          });
          if (temAltura) {
            createRacksFromJSON(grupo);
          } else {
            createCorridorsFromJSON(grupo);
          }

          // Criar checkbox
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.id = `chk-${tipo}`;
          checkbox.checked = !temAltura; // checked se era plano originalmente

          const label = document.createElement("label");
          label.htmlFor = checkbox.id;
          label.textContent = ` Mostrar ${tiposMap[tipo][0].Spazio_tipoD} sem alturas`;
          label.style.display = "block";
          label.style.marginBottom = "5px";
          label.prepend(checkbox);
          const li = document.createElement("li");
          li.appendChild(label);
          document.getElementById("grupo-lista-tipos").appendChild(li);

          // Evento de troca de estado
          checkbox.addEventListener("change", () => {
            if (checkbox.checked) {
              // Substitua 'rackGroup' pelo grupo onde o mesh foi adicionado originalmente
              classeDivEspacosMeshes
                .filter((mesh) => mesh.userData?.tipo === tipo)
                .forEach((mesh) => {
                  rackGroup.remove(mesh); // ou scene.remove(mesh), dependendo de onde foi adicionado
                  mesh.geometry?.dispose?.();
                  mesh.material?.dispose?.();
                });

              // Remover do array também
              classeDivEspacosMeshes = classeDivEspacosMeshes.filter(
                (mesh) => mesh.userData?.tipo !== tipo
              );

              rackGroup.children
                .filter((child) => child.userData?.tipo === tipo)
                .forEach((child) => {
                  rackGroup.remove(child);
                  child.geometry?.dispose?.();
                  child.material?.dispose?.();
                });

              // Recriar baseado no estado da checkbox
              createCorridorsFromJSON(grupo); // mostrar como corredor
            } else {
              // Remover da cena (corridorGroup)
              classeDivEspacosMeshes
                .filter((mesh) => mesh.userData?.tipo === tipo)
                .forEach((mesh) => {
                  corridorGroup.remove(mesh); // remove do grupo correto
                  mesh.geometry?.dispose?.();
                  mesh.material?.dispose?.();
                });

              // Remover do array auxiliar
              classeDivEspacosMeshes = classeDivEspacosMeshes.filter(
                (mesh) => mesh.userData?.tipo !== tipo
              );

              // Garantir que nenhum outro filho permaneça no grupo
              corridorGroup.children
                .filter((child) => {
                  child.userData?.tipo === tipo;
                })
                .forEach((child) => {
                  corridorGroup.remove(child);
                  child.geometry?.dispose?.();
                  child.material?.dispose?.();
                });

              createRacksFromJSON(grupo); // mostrar como rack
            }
          });
        }
      }

      function capitalizeFirstLetter(str) {
        if (typeof str !== "string") return str;
        return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
      }

      //Nova função realizada por GM para representar os espaços
      async function createCorridorsFromJSON(corridors) {
        const corridorOpacity = 0.95;
        const shrinkFactor = 1.0;
        const defaultColor = new THREE.Color("#3399ff");

        const baseGeometry = new THREE.PlaneGeometry(1, 1);
        const dummy = new THREE.Object3D();
        const count = corridors.length;

        const material = new THREE.MeshBasicMaterial({
          vertexColors: true,
          transparent: true,
          opacity: corridorOpacity,
          side: THREE.DoubleSide,
          depthWrite: false,
          polygonOffset: true,
          polygonOffsetFactor: -1,
          polygonOffsetUnits: -1,
        });

        const instancedMesh = new THREE.InstancedMesh(
          baseGeometry,
          material,
          count
        );
        instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage); // caso queira atualizá-los depois
        instancedMesh.userData.tipo = "corridorMesh"; // valor genérico (pode ser sobrescrito)

        const colorArray = new Float32Array(count * 3);
        const color = new THREE.Color();

        const outlineGeometry = new THREE.EdgesGeometry(baseGeometry);
        const outlineMaterial = new THREE.LineBasicMaterial({
          color: 0x000000,
          transparent: true,
          opacity: 0.6,
        });

        const outlineGroup = new THREE.Group();

        corridors.forEach((corridor, index) => {
          const x = parseFloat(corridor.Spazio_coord_draw_a || 0) / 100;
          const z = parseFloat(corridor.Spazio_coord_draw_c || 0) / 100;

          let width = parseFloat(corridor.Spazio_coord_largo || 100) / 100;
          let depth = parseFloat(corridor.Spazio_coord_fondo || 100) / 100;

          const orientation = String(corridor.Spazio_orientamento || "").trim();
          if (orientation === "1") [width, depth] = [depth, width];

          const scaleX = width * shrinkFactor;
          const scaleZ = depth * shrinkFactor;
          const y = 0.01 + index * 0.0001; // evita z-fighting

          // Matriz de transformação
          dummy.position.set(x + width / 2, y, z + depth / 2);
          dummy.rotation.x = -Math.PI / 2;
          dummy.scale.set(scaleX, scaleZ, 1);
          dummy.updateMatrix();
          instancedMesh.setMatrixAt(index, dummy.matrix);
          instancedMesh.userData.tipo = corridor.Spazio_tipo;
          instancedMesh.userData.tipoD = corridor.Spazio_tipoD;
          instancedMesh.userData.spazio_disp = corridor.Spazio_disponibile;

          // Cor por instância
          try {
            color.set((corridor.ColoreD || "#3399ff").toLowerCase());
          } catch {
            color.copy(defaultColor);
          }
          color.toArray(colorArray, index * 3);

          // Contorno
          const outline = new THREE.LineSegments(
            outlineGeometry.clone(),
            outlineMaterial.clone()
          );
          outline.applyMatrix4(dummy.matrix);
          outline.visible = true; // pode ser false se quiser só mostrar onHover
          outline.userData.tipo = corridor.Spazio_tipo;

          outlineGroup.add(outline);
          outlinesArray.push({
            outline,
            position: dummy.position.clone(),
          });
          classeDivEspacosMeshes.push(outline);
        });

        instancedMesh.geometry.setAttribute(
          "color",
          new THREE.InstancedBufferAttribute(colorArray, 3)
        );
        instancedMesh.instanceMatrix.needsUpdate = true;

        corridorGroup.add(instancedMesh);
        corridorGroup.add(outlineGroup);

        classeDivEspacosMeshes.push(instancedMesh);

        console.log(`Corredores desenhados (instanced): ${count}`);
      }

      //FUNÇÃO PARA CRIAÇÃO DE CAIS ALTERAÇÃO GM
      /*async function createDockFromJSON(docks) {
        docks.forEach((dock) => {
          const x = parseFloat(dock.Spazio_coord_draw_a) / 100;
          const z = parseFloat(dock.Spazio_coord_draw_c) / 100;

          let width = parseFloat(dock.Spazio_coord_largo) / 100;
          let depth = parseFloat(dock.Spazio_coord_fondo) / 100;

          const orientation = String(dock.Spazio_orientamento).trim();
          if (orientation === "1") {
            const temp = width;
            width = depth;
            depth = temp;
          }
          const geometry = new THREE.BoxGeometry(width, 0, depth);
          const material = new THREE.MeshStandardMaterial({
            color: dock.cor || "#73a7f5",
            transparent: true,
            opacity: 0.9,
            depthWrite: false,
          });

          const mesh = new THREE.Mesh(geometry, material);

          // Y mínimo para aparecer no chão mas sem afundar
          mesh.position.set(x + width / 2, 0.03, z + depth / 2);

          dockGroup.add(mesh);

          const edges = new THREE.EdgesGeometry(geometry);
          const line = new THREE.LineSegments(
            edges,
            new THREE.LineBasicMaterial({ color: 0xffffff })
          );
          line.position.copy(mesh.position);
          classeCaisMeshes.push(mesh);

          dockGroup.add(line);
        });
      } */

      //ESTA FUNÇA USADA PARA GERAR AS PILHAS -> GM ALTERAÇÃO
      async function createStacksFromJSON(stacks) {
        const stackColor = 0x9966ff;
        const stackOpacity = 0.95;
        const boxHeight = 0.6; // altura de cada caixa empilhada (em metros)

        stacks.forEach((stack) => {
          const x = parseFloat(stack.Spazio_coord_draw_a) / 100;
          const y = parseFloat(stack.Spazio_coord_draw_b) / 100;
          const z = parseFloat(stack.Spazio_coord_draw_c) / 100;

          let width = parseFloat(stack.Spazio_coord_largo) / 100;
          const height = parseFloat(stack.Spazio_coord_alto) / 100;
          let depth = parseFloat(stack.Spazio_coord_fondo) / 100;

          const orientation = String(stack.Spazio_orientamento).trim();
          if (orientation === "1") {
            const temp = width;
            width = depth;
            depth = temp;
          }
          const numBoxes = Math.floor(height / boxHeight);
          const geometry = new THREE.BoxGeometry(width, boxHeight, depth);
          const material = new THREE.MeshBasicMaterial({
            color: stack.color || stackColor,
            transparent: true,
            opacity: stackOpacity,
          });

          for (let i = 0; i < numBoxes; i++) {
            const box = new THREE.Mesh(geometry, material);
            box.position.set(
              x + width / 2,
              y + boxHeight / 2 + i * boxHeight,
              z + depth / 2
            );
            box.userData.type = "Pilha";

            stackGroup.add(box);
            stackMeshes.push(box);

            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(
              edges,
              new THREE.LineBasicMaterial({ color: 0xffffff })
            );
            line.position.copy(box.position);
            stackGroup.add(line);
          }

          // Adiciona 4 linhas verticais na frente e atrás para visual
          for (let i = 1; i < 4; i++) {
            const offset = (width / 4) * i;

            const geometryFront = new THREE.BufferGeometry().setFromPoints([
              new THREE.Vector3(x + offset, y, z),
              new THREE.Vector3(x + offset, y + height, z),
            ]);
            const lineFront = new THREE.Line(
              geometryFront,
              new THREE.LineBasicMaterial({ color: 0xffffff })
            );
            stackGroup.add(lineFront);

            const geometryBack = new THREE.BufferGeometry().setFromPoints([
              new THREE.Vector3(x + offset, y, z + depth),
              new THREE.Vector3(x + offset, y + height, z + depth),
            ]);
            const lineBack = new THREE.Line(
              geometryBack,
              new THREE.LineBasicMaterial({ color: 0xffffff })
            );
            stackGroup.add(lineBack);
          }
        });

        console.log(`Pilhas desenhadas: ${stacks.length}`);
      }

      //ESTA FUNÇÃO É USADA PARA GERAR DRIVE-INS
      async function createDriveInsFromJSON(driveIns) {
        driveIns.forEach((driveIn) => {
          const x = parseFloat(driveIn.Spazio_coord_draw_a) / 100;
          const y = parseFloat(driveIn.Spazio_coord_draw_b) / 100;
          const z = parseFloat(driveIn.Spazio_coord_draw_c) / 100;

          let width = parseFloat(driveIn.Spazio_coord_largo) / 100;
          const height = parseFloat(driveIn.Spazio_coord_alto) / 100;
          let depth = parseFloat(driveIn.Spazio_coord_fondo) / 100;

          const orientation = String(driveIn.Spazio_orientamento).trim();
          if (orientation === "1") {
            const temp = width;
            width = depth;
            depth = temp;
          }
          const geometry = new THREE.BoxGeometry(width, height, depth);
          const material = new THREE.MeshBasicMaterial({
            color: driveIn.cor || "#f7e36a",
            transparent: true,
            opacity: 0.95,
            depthWrite: true,
          });

          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.set(x + width / 2, y + height / 2, z + depth / 2);
          driveInGroup.add(mesh);

          const edges = new THREE.EdgesGeometry(geometry);
          const line = new THREE.LineSegments(
            edges,
            new THREE.LineBasicMaterial({ color: 0xffffff })
          );

          line.position.copy(mesh.position);
          driveInMeshes.push(mesh);

          driveInGroup.add(line);
        });

        console.log(`Drive-ins desenhados: ${driveIns.length}`);
      }
      // Fetch JSON data and start rendering

      function applyInitialLabelVisibilityFromMenu() {
        document.querySelectorAll(".label-toggle").forEach((checkbox) => {
          const type = checkbox.value;
          const visible = checkbox.checked;
          const labels = labelRenderer.domElement.querySelectorAll(
            `.toggle-label-${type}`
          );
          labels.forEach((el) => {
            el.style.visibility = visible ? "visible" : "hidden";
          });
        });
      }

      window.onload = function () {
        fetch("resources/data/dados_limpo.json")
          .then((response) => response.json())
          .then(async (data) => {
            trocarCoordenadasBC(data);

            const val = await extractDataFromJSON(data);
            mirrorDataXCoordinates(val);

            //ALTERAÇAO GM
            // Adicionar o GridHelper com base no tamanho real do armazém
            const bounds = new THREE.Box3();
            [
              ...classeEspExecMeshes,
              ...classeCaisMeshes,
              ...classeDivEspacosMeshes,
              ...classeZonAnomalasMeshes,
              ...classeEspacoDistrMeshes,
              ...classeTransportesMeshes,
              ...classeTransicaoMeshes,
              ...classePilhaMeshes,
              ...classeCaisTemporarioMeshes,
            ].forEach((mesh) => bounds.expandByObject(mesh));

            const originalMargin = 20;

            const adjustedMin = bounds.min.clone().subScalar(originalMargin);
            const adjustedMax = bounds.max.clone().addScalar(originalMargin);

            const largura = adjustedMax.x - adjustedMin.x;
            const profundidade = adjustedMax.z - adjustedMin.z;
            const centerX = (adjustedMin.x + adjustedMax.x) / 2;
            const centerZ = (adjustedMin.z + adjustedMax.z) / 2;

            const gridSize = Math.max(largura, profundidade);
            const gridDivisions = Math.floor(gridSize / 5);

            const gridHelper = new THREE.GridHelper(
              gridSize,
              gridDivisions,
              0x555a66,
              0x555a66
            );
            gridHelper.position.set(centerX, 0.01, centerZ);
            scene.add(gridHelper);

            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = "absolute";
            labelRenderer.domElement.style.top = "0px";
            labelRenderer.domElement.style.pointerEvents = "none";
            document.body.appendChild(labelRenderer.domElement);

            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setAnimationLoop(animate);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.VSMShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            container.appendChild(renderer.domElement);

            stats.domElement.style.position = "fixed";
            stats.domElement.style.bottom = "10px";
            stats.domElement.style.right = "10px";
            stats.domElement.style.left = ""; // limpa se existir
            stats.domElement.style.top = ""; // limpa para não se sobrepor
            stats.domElement.style.zIndex = "9999";

            document.body.appendChild(stats.domElement);

            container.appendChild(stats.domElement);
            toggleCamera();
          })
          .catch((error) => console.error("Error fetching JSON:", error));
      };

      function isNotHidden(obj) {
        if (obj.userData.hidden) return false;
        let parent = obj.parent;
        while (parent) {
          if (parent.userData && parent.userData.hidden) return false;
          parent = parent.parent;
        }
        return true;
      }

      //Tutorial button ALTERAÇAO GM
      const tutorialBtn = document.getElementById("tutorial-btn");
      const tooltipTutorial = document.getElementById("tutorial-tooltip");

      let isTooltipVisible = false;

      tutorialBtn.addEventListener("click", () => {
        isTooltipVisible = !isTooltipVisible;
        tooltipTutorial.classList.toggle("show", isTooltipVisible);
      });

      //Oculta se clicar fora
      document.addEventListener("click", (e) => {
        if (
          !tooltipTutorial.contains(e.target) &&
          !tutorialBtn.contains(e.target) &&
          isTooltipVisible
        ) {
          tooltipTutorial.classList.remove("show");
          isTooltipVisible = false;
        }
      });

      //SIDE BAR JS ALTERAÇÃO GM
      const sidebarToggle = document.getElementById("sidebar-toggle");
      const sidebar = document.getElementById("sidebar");

      let isSidebarVisible = true;

      sidebarToggle.addEventListener("click", () => {
        isSidebarVisible = !isSidebarVisible;

        if (isSidebarVisible) {
          sidebar.style.transform = "translateX(0)";
          sidebarToggle.innerHTML = "❮";
          sidebarToggle.style.left = "250px";
        } else {
          sidebar.style.transform = "translateX(-250px)";
          sidebarToggle.innerHTML = "❯";
          sidebarToggle.style.left = "0px";
        }
      });

      //TOGGLE CAPTIONS JS ALTERAÇÃO GM
      const toggleCaptionsBtn = document.getElementById("toggle-captions-btn");
      const legendPopup = document.getElementById("legend-popup");

      //Toggle visibilidade
      toggleCaptionsBtn.addEventListener("click", () => {
        legendPopup.classList.toggle("hidden");
      });

      //Função drag
      let isDragging = false;
      let offsetX, offsetY;

      legendPopup.addEventListener("mousedown", (e) => {
        isDragging = true;
        offsetX = e.clientX - legendPopup.offsetLeft;
        offsetY = e.clientY - legendPopup.offsetTop;
      });
      document.addEventListener("mousemove", (e) => {
        if (isDragging) {
          legendPopup.style.left = `${e.clientX - offsetX}px`;
          legendPopup.style.top = `${e.clientY - offsetY}px`;
        }
      });

      document.addEventListener("mouseup", () => {
        isDragging = false;
      });
    </script>
  </body>
</html>
